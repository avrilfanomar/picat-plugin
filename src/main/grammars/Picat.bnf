{
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  parserClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParser"
  parserUtilClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParserUtil"
  psiClassPrefix="Picat"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.avrilfanomar.picatplugin.language.psi"
  psiImplPackage="com.github.avrilfanomar.picatplugin.language.psi.impl"

  elementTypeHolderClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenTypes"
  elementTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatElementType"
  tokenTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenType"

  tokens = [
    // Keywords
    MODULE_KEYWORD="module"
    IMPORT_KEYWORD="import"
    INCLUDE_KEYWORD="include"
    PRIVATE_KEYWORD="private"
    TABLE_KEYWORD="table"
    INDEX_KEYWORD="index"
    IF_KEYWORD="if"
    THEN_KEYWORD="then"
    ELSEIF_KEYWORD="elseif"
    ELSE_KEYWORD="else"
    END_KEYWORD="end"
    FOREACH_KEYWORD="foreach"
    IN_KEYWORD="in"
    WHILE_KEYWORD="while"
    LOOP_KEYWORD="loop"
    TRY_KEYWORD="try"
    CATCH_KEYWORD="catch"
    FINALLY_KEYWORD="finally"
    NOT_KEYWORD="not"
    DIV_KEYWORD="div"
    MOD_KEYWORD="mod"
    REM_KEYWORD="rem"
    LAMBDA_KEYWORD="lambda"
    CARDINALITY_KEYWORD="cardinality"
    MIN_KEYWORD="min"
    MAX_KEYWORD="max"

    // Operators
    ARROW_OP="=>"
    BACKTRACKABLE_ARROW_OP="?=>"
    BICONDITIONAL_OP="<=>"
    HASH_BICONDITIONAL_OP="#<=>"
    HASH_ARROW_OP="#=>"
    HASH_OR_OP="#\\/"
    HASH_XOR_OP="#^"
    HASH_AND_OP="#/\\"
    HASH_NOT_OP="#~"
    HASH_EQUAL_OP="#="
    HASH_NOT_EQUAL_OP="#!="
    HASH_GREATER_OP="#>"
    HASH_GREATER_EQUAL_OP="#>="
    HASH_LESS_OP="#<"
    HASH_LESS_EQUAL_OP="#=<"
    HASH_LESS_EQUAL_ALT_OP="#<="
    ASSIGN_OP=":="
    DOUBLE_COLON_OP="::"
    RANGE_OP=".."
    EQUAL="="
    NOT_EQUAL="!="
    IDENTICAL="=="
    NOT_IDENTICAL="!=="
    LESS="<"
    GREATER=">"
    LESS_EQUAL="<="
    GREATER_EQUAL=">="
    LESS_EQUAL_PROLOG="=<"
    PLUS="+"
    MINUS="-"
    MULTIPLY="*"
    DIVIDE="/"
    INT_DIVIDE="//"
    DIV_RIGHT="/>"
    DIV_LEFT="/<"
    POWER="**"
    CONCAT_OP="++"
    SHIFT_LEFT="<<"
    SHIFT_RIGHT=">>"
    SHIFT_RIGHT_TRIPLE=">>>"
    BITWISE_OR="\\/"
    BITWISE_XOR="^"
    BITWISE_AND="/\\"
    COMPLEMENT="~"

    // Separators
    DOT="."
    COMMA=","
    SEMICOLON=";"
    COLON=":"
    LPAR="("
    RPAR=")"
    LBRACKET="["
    RBRACKET="]"
    LBRACE="{"
    RBRACE="}"
    PIPE="|"
    AT="@"
    DOLLAR="$"

    // Literals
    IDENTIFIER="regexp:[a-z][a-zA-Z0-9_]*"
    VARIABLE="regexp:[A-Z_][a-zA-Z0-9_]*"
    INTEGER="regexp:[0-9]+"
    FLOAT="regexp:[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?"
    STRING="regexp:\"([^\"\\]|\\\\.)*\""
    COMMENT="regexp:%[^\r\n]*"
    QUALIFIED_ATOM="regexp:[a-z][a-zA-Z0-9_]*\\.[a-z][a-zA-Z0-9_]*"
  ]
}

program ::= program_item*

program_item ::= module_declaration
               | import_declaration
               | include_declaration
               | predicate_definition
               | function_definition
               | actor_definition

// Module declaration
module_declaration ::= MODULE_KEYWORD atom DOT {pin=1}

// Import declarations - fixed to handle the actual syntax
import_declaration ::= IMPORT_KEYWORD import_item (COMMA import_item)* DOT {pin=1}
// Fixed: import items can be simple atoms or qualified atoms with optional arity
import_item ::= (atom | QUALIFIED_ATOM) [DIV_RIGHT INTEGER]

// Include declarations
include_declaration ::= INCLUDE_KEYWORD STRING (COMMA STRING)* DOT {pin=1}

// Predicate definitions - fixed to properly handle facts without extra rules
predicate_definition ::= predicate_directive* predicate_clause

predicate_clause ::= predicate_rule | predicate_fact

predicate_rule ::= head [COMMA condition] (ARROW_OP | BACKTRACKABLE_ARROW_OP) body DOT {pin=3}

predicate_fact ::= head DOT {pin=2}

// Function definitions - fixed similar to predicates
function_definition ::= function_directive* function_clause

function_clause ::= function_rule | function_fact

function_rule ::= head EQUAL VARIABLE [COMMA condition] ARROW_OP body DOT {pin=2}

function_fact ::= head EQUAL argument DOT {pin=2}

// Actor definitions
actor_definition ::= [PRIVATE_KEYWORD] action_rule (action_rule | nonbacktrackable_predicate_rule)*

action_rule ::= head [COMMA condition] COMMA LBRACE event_pattern RBRACE ARROW_OP body DOT

nonbacktrackable_predicate_rule ::= head [COMMA condition] ARROW_OP body DOT

event_pattern ::= term (COMMA term)*

// Directives
function_directive ::= PRIVATE_KEYWORD | TABLE_KEYWORD

predicate_directive ::= PRIVATE_KEYWORD
                     | TABLE_KEYWORD [LPAR table_mode (COMMA table_mode)* RPAR]
                     | INDEX_KEYWORD LPAR index_mode (COMMA index_mode)* RPAR

index_mode ::= PLUS | MINUS
table_mode ::= PLUS | MINUS | MIN_KEYWORD | MAX_KEYWORD

head ::= atom [LPAR [argument (COMMA argument)*] RPAR]

// Condition and body
condition ::= goal
body ::= goal

// Goals - following the official precedence hierarchy
goal ::= disjunctive_goal

disjunctive_goal ::= conjunctive_goal (SEMICOLON disjunctive_goal)*

conjunctive_goal ::= negative_goal (COMMA conjunctive_goal)*

negative_goal ::= (NOT_KEYWORD negative_goal) | equiv_constr

equiv_constr ::= impl_constr (HASH_BICONDITIONAL_OP impl_constr)*

impl_constr ::= or_constr (HASH_ARROW_OP or_constr)*

or_constr ::= xor_constr (HASH_OR_OP xor_constr)*

xor_constr ::= and_constr (HASH_XOR_OP and_constr)*

and_constr ::= not_constr (HASH_AND_OP not_constr)*

not_constr ::= (HASH_NOT_OP not_constr) | enclosed_goal

enclosed_goal ::= if_then_else
                | foreach_loop
                | while_loop
                | loop_while
                | try_catch
                | type_annotation
                | expression_with_relations

if_then_else ::= IF_KEYWORD goal THEN_KEYWORD goal (ELSEIF_KEYWORD goal THEN_KEYWORD goal)* ELSE_KEYWORD goal END_KEYWORD

foreach_loop ::= FOREACH_KEYWORD LPAR iterator (COMMA (iterator | condition))* RPAR goal END_KEYWORD

while_loop ::= WHILE_KEYWORD LPAR goal RPAR [LOOP_KEYWORD] goal END_KEYWORD

loop_while ::= LOOP_KEYWORD goal WHILE_KEYWORD LPAR goal RPAR

try_catch ::= TRY_KEYWORD goal catch_clause* [FINALLY_KEYWORD goal] END_KEYWORD

catch_clause ::= CATCH_KEYWORD LPAR exception_pattern RPAR goal

exception_pattern ::= term

expression_with_relations ::= expression (bin_rel_op expression)*

bin_rel_op ::= EQUAL | NOT_EQUAL | ASSIGN_OP | IDENTICAL | NOT_IDENTICAL
             | GREATER | GREATER_EQUAL | LESS | LESS_EQUAL | LESS_EQUAL_PROLOG
             | IN_KEYWORD | HASH_EQUAL_OP | HASH_NOT_EQUAL_OP | HASH_GREATER_OP
             | HASH_GREATER_EQUAL_OP | HASH_LESS_OP | HASH_LESS_EQUAL_OP | HASH_LESS_EQUAL_ALT_OP

// Arguments and expressions
argument ::= negative_goal

expression ::= range_expression

range_expression ::= or_expression [RANGE_OP or_expression [RANGE_OP or_expression]]

or_expression ::= xor_expression (BITWISE_OR xor_expression)*

xor_expression ::= and_expression (BITWISE_XOR and_expression)*

and_expression ::= shift_expression (BITWISE_AND shift_expression)*

shift_expression ::= additive_expression ((SHIFT_LEFT | SHIFT_RIGHT | SHIFT_RIGHT_TRIPLE) additive_expression)*

additive_expression ::= multiplicative_expression ((PLUS | CONCAT_OP | MINUS) multiplicative_expression)*

multiplicative_expression ::= unary_expression ((MULTIPLY | DIVIDE | INT_DIVIDE | DIV_RIGHT | DIV_LEFT | DIV_KEYWORD | MOD_KEYWORD | REM_KEYWORD) unary_expression)*

unary_expression ::= power_expression
                   | PLUS unary_expression
                   | MINUS unary_expression
                   | COMPLEMENT unary_expression

power_expression ::= primary_expression [POWER unary_expression]

primary_expression ::= base_expression

//TODO space after dot access is still allowed and results in parsing issues
//primary_expression ::= base_expression postfix_operations?
//postfix_operations ::= postfix_operation postfix_operations?
//postfix_operation ::= dot_access
//dot_access ::= DOT !<<isWhitespaceNext>> atom_or_call
//atom_or_call ::= atom [LPAR [argument (COMMA argument)*] RPAR]

base_expression ::= parenthesized_goal
                  | variable_index
                  | as_pattern
                  | VARIABLE
                  | INTEGER
                  | FLOAT
                  | atom_without_args
                  | function_call
                  | list_expression
                  | array_expression
                  | lambda_term
                  | term_constructor

// Separate atom without arguments from function calls
atom_without_args ::= atom !(LPAR)

// Function calls should not be followed by dot access in statement contexts
function_call ::= atom LPAR [argument (COMMA argument)*] RPAR

parenthesized_goal ::= LPAR goal RPAR

type_annotation ::= VARIABLE DOUBLE_COLON_OP expression

variable_index ::= VARIABLE LBRACKET argument [COMMA argument] RBRACKET

as_pattern ::= VARIABLE AT term [AT]

list_expression ::= LBRACKET argument list_expression_suffix RBRACKET

list_expression_suffix ::= COLON iterator (COMMA (iterator | condition))*  // list comprehension
                        | (COMMA argument)* [PIPE argument]                // regular list

array_expression ::= LBRACE argument (COMMA argument)* RBRACE

lambda_term ::= LAMBDA_KEYWORD LPAR variable_list COMMA argument RPAR

variable_list ::= LBRACKET [variable (COMMA variable)*] RBRACKET

term_constructor ::= DOLLAR goal DOLLAR

// Iterator for comprehensions and loops
iterator ::= variable IN_KEYWORD expression | variable EQUAL expression

term ::=
    LPAR term RPAR
  | variable_as_pattern
  | VARIABLE
  | INTEGER
  | FLOAT
  | atom_or_call_no_lambda
  | list_expression_no_comprehension
  | array_expression
  | function_call_no_dot
  | term_constructor

variable_as_pattern ::= VARIABLE AT term [AT]
atom_or_call_no_lambda ::= atom [LPAR [term (COMMA term)*] RPAR]
list_expression_no_comprehension ::= LBRACKET [term (COMMA term)*] [PIPE term] RBRACKET
function_call_no_dot ::= atom LPAR [term (COMMA term)*] RPAR
atom ::= IDENTIFIER
