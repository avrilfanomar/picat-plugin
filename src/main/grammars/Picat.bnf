{
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  parserClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParser"
  parserUtilClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParserUtil"
  psiClassPrefix="Picat"
  psiImplClassSuffix="Impl"
  psiImplUtilClass="com.github.avrilfanomar.picatplugin.language.psi.PicatPsiImplUtil"
  psiPackage="com.github.avrilfanomar.picatplugin.language.psi"
  psiImplPackage="com.github.avrilfanomar.picatplugin.language.psi.impl"

  elementTypeHolderClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenTypes"
  elementTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatElementType"
  tokenTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenType"

  tokens = [
    // Keywords
    MODULE_KEYWORD="module"
    IMPORT_KEYWORD="import"
    INCLUDE_KEYWORD="include"
    PRIVATE_KEYWORD="private"
    TABLE_KEYWORD="table"
    INDEX_KEYWORD="index"
    IF_KEYWORD="if"
    THEN_KEYWORD="then"
    ELSEIF_KEYWORD="elseif"
    ELSE_KEYWORD="else"
    END_KEYWORD="end"
    FOREACH_KEYWORD="foreach"
    IN_KEYWORD="in"
    NOT_IN_KEYWORD="notin"
    WHILE_KEYWORD="while"
    LOOP_KEYWORD="loop"
    TRY_KEYWORD="try"
    CATCH_KEYWORD="catch"
    FINALLY_KEYWORD="finally"
    THROW_KEYWORD="throw"
    NOT_KEYWORD="not"
    DIV_KEYWORD="div"
    MOD_KEYWORD="mod"
    REM_KEYWORD="rem"
    LAMBDA_KEYWORD="lambda"
    CARDINALITY_KEYWORD="cardinality"
    FAIL_KEYWORD="fail"
    REPEAT_KEYWORD="repeat"
    UNTIL_KEYWORD="until"
    ONCE_KEYWORD="once"
    IS_KEYWORD="is"

    // Operators
    SHIFT_RIGHT_TRIPLE=">>>"
    BACKTRACKABLE_ARROW_OP="?=>"
    BICONDITIONAL_OP="<=>"
    HASH_BICONDITIONAL_OP="#<=>"
    HASH_NOT_EQUAL_OP="#!="
    HASH_ARROW_OP="#=>"
    HASH_GREATER_EQUAL_OP="#>="
    HASH_LESS_EQUAL_OP="#=<"
    HASH_LESS_EQUAL_ALT_OP="#<="
    AT_GREATER_EQUAL_OP="@>="
    AT_LESS_EQUAL_OP="@<="
    AT_LESS_EQUAL_PROLOG_OP="@=<"
    NUMERICALLY_EQUAL="=:="
    NUMERICALLY_NON_EQUAL="=\="
    NOT_IDENTICAL="!=="
    HASH_AND_OP="#/\"
    HASH_OR_OP="#\/"
    HASH_XOR_OP="#^"
    HASH_NOT_BACKSLASH_OP='#\'
    IF_THEN_OP="->"
    ARROW_OP="=>"
    HASH_NOT_OP="#~"
    HASH_EQUAL_OP="#="
    HASH_GREATER_OP="#>"
    HASH_LESS_OP="#<"
    AT_GREATER_OP="@>"
    AT_LESS_OP="@<"
    ASSIGN_OP=":="
    DOUBLE_COLON_OP="::"
    RANGE_OP=".."
    NOT_EQUAL="!="
    IDENTICAL="=="
    GREATER=">"
    LESS_EQUAL="<="
    GREATER_EQUAL=">="
    LESS_EQUAL_PROLOG="=<"
    DIV_RIGHT="/>"
    DIV_LEFT="/<"
    POWER="**"
    PROLOG_RULE_OP=":-"
    CONCAT_OP="++"
    SHIFT_LEFT="<<"
    SHIFT_RIGHT=">>"
    INT_DIVIDE="//"
    BITWISE_AND='/\'
    BITWISE_OR="\/"
    DIVIDE="/"
    EQUAL="="
    LESS="<"
    PLUS="+"
    MINUS="-"
    MIN="min"
    MAX="max"
    NT="nt"
    MULTIPLY="*"
    BITWISE_XOR="^"
    COMPLEMENT="~"
    EXCLAMATION="!"
    AND_AND="&&"
    OR_OR="||"
    UNIV_OP="=.."
    NOT_IDENTICAL_PROLOG_OP="\=="
    NOT_UNIFIABLE_OP="\="
    BACKSLASH_PLUS="\\+"

    // Separators
    COMMA=","
    SEMICOLON=";"
    COLON=":"
    LPAR="("
    RPAR=")"
    LBRACKET="["
    RBRACKET="]"
    LBRACE="{"
    RBRACE="}"
    PIPE="|"
    AT="@"
    DOLLAR="$"

    // Literals
    IDENTIFIER="regexp:[a-z][a-zA-Z0-9_]*"
    DOT_IDENTIFIER="regexp:\.[a-z][a-zA-Z0-9_]*"
    VARIABLE="regexp:[A-Z_][a-zA-Z0-9_]*"
    INTEGER="regexp:([0-9]+|0[xX][0-9a-fA-F]+|0[oO][0-7]+|0[bB][01]+|0'(\\.|[^\n]))"
    FLOAT="regexp:[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?"
    STRING="regexp:\"(\\.|[^\"\\])*\""
    SINGLE_QUOTED_ATOM="regexp:'([^'\\]|\\.)*'"
    DOT_SINGLE_QUOTED_ATOM="regexp:\\.'([^'\\]|\\.)*'"
    DOT="."
    COMMENT="regexp:%.*"
    QUALIFIED_ATOM="regexp:[a-z][a-zA-Z0-9_]*\.[a-z][a-zA-Z0-9_]*"
    MULTILINE_COMMENT="regexp:/[*]([^*]|[*][^/])*[*]/"
    TRUE="true"
    FALSE="false"
  ]
}

// === Root ===
program ::= program_item*

program_item ::= MULTILINE_COMMENT
               | COMMENT
               | module_declaration
               | import_declaration
               | include_declaration
               | function_definition
               | predicate_definition
               | actor_definition
               | DOT

// === Module & Imports ===
module_declaration ::= MODULE_KEYWORD atom DOT {pin=1}

import_declaration ::= IMPORT_KEYWORD import_item (COMMA import_item)* DOT {pin=1}

import_item ::= (atom | QUALIFIED_ATOM) [DIV_RIGHT INTEGER]

include_declaration ::= INCLUDE_KEYWORD STRING (COMMA STRING)* DOT {pin=1}

// === Predicate and Function Definitions ===
predicate_definition ::= predicate_directive* predicate_clause

predicate_clause ::= predicate_rule | predicate_fact

predicate_rule ::= head &(COMMA | ARROW_OP | BACKTRACKABLE_ARROW_OP | PROLOG_RULE_OP) [COMMA condition] (ARROW_OP | BACKTRACKABLE_ARROW_OP | PROLOG_RULE_OP) body DOT {pin=4}

predicate_fact ::= head DOT {pin=2}

function_definition ::= function_directive* function_clause

function_clause ::= function_rule | function_fact

function_rule ::= head EQUAL argument function_rule_tail DOT
function_rule_tail ::= [COMMA condition] ARROW_OP body {pin=2;recoverWhile=function_rule_tail_recover}
private function_rule_tail_recover ::= !DOT

function_fact ::= head EQUAL argument DOT {pin=2}

// === Actor Definitions ===
actor_definition ::= [PRIVATE_KEYWORD] action_rule (action_rule | nonbacktrackable_predicate_rule)*

action_rule ::= head [COMMA condition] COMMA LBRACE event_pattern RBRACE ARROW_OP body DOT

nonbacktrackable_predicate_rule ::= head [COMMA condition] ARROW_OP body DOT

event_pattern ::= term (COMMA term)*

// === Directives ===
function_directive ::= PRIVATE_KEYWORD | TABLE_KEYWORD

predicate_directive ::= PRIVATE_KEYWORD
                     | TABLE_KEYWORD [LPAR table_mode (COMMA table_mode)* RPAR]
                     | INDEX_KEYWORD (LPAR index_mode (COMMA index_mode)* RPAR)+

index_mode ::= PLUS | MINUS
table_mode ::= PLUS | MINUS | MIN | MAX | NT

// === Heads ===
head ::= atom head_args?
head_args ::= LPAR head_args_inner RPAR {pin=1}
private head_args_inner ::= [argument (COMMA argument)*] {recoverWhile=head_args_recover}
private head_args_recover ::= !RPAR

// === Conditions & Bodies ===
condition ::= goal
body ::= goal

// === Goal (Expressions and Control) ===
goal ::= disjunction
       | FAIL_KEYWORD
       | REPEAT_KEYWORD [goal UNTIL_KEYWORD goal]
       | ONCE_KEYWORD goal

disjunction ::= if_then ((SEMICOLON | OR_OR) if_then)*

//avoid exponential backtracking
if_then ::= conjunction [IF_THEN_OP conjunction]

conjunction ::= enclosed_goal conjunction_tail?

conjunction_tail ::= (COMMA | AND_AND) !RPAR goal conjunction_tail? {pin=1 recoverWhile=conjunction_recover}

negation ::= (NOT_KEYWORD | BACKSLASH_PLUS) negation | equivalence

equivalence ::= implication (HASH_BICONDITIONAL_OP implication)*

implication ::= disjunction_or (HASH_ARROW_OP disjunction_or)*

disjunction_or ::= exclusive_or (HASH_OR_OP exclusive_or)*

exclusive_or ::= conjunction_and (HASH_XOR_OP conjunction_and)*

conjunction_and ::= negated (HASH_AND_OP negated)*

negated ::= HASH_NOT_OP negated | HASH_NOT_BACKSLASH_OP negated | expression_with_relations

// Control structures and annotated expressions
enclosed_goal ::= if_then_else
                | foreach_loop
                | while_loop
                | loop_while
                | try_catch
                | throw_statement
                | type_annotation
                | NOT_KEYWORD goal
                | BACKSLASH_PLUS goal
                | equivalence
                | expression_with_relations

if_then_else ::= IF_KEYWORD if_condition THEN_KEYWORD if_goal (ELSEIF_KEYWORD elseif_condition THEN_KEYWORD if_goal)* (ELSE_KEYWORD if_goal)? END_KEYWORD {pin=1}
if_condition ::= goal {recoverWhile=if_condition_recover}
private if_condition_recover ::= !THEN_KEYWORD
elseif_condition ::= goal {recoverWhile=elseif_condition_recover}
private elseif_condition_recover ::= !THEN_KEYWORD
if_goal ::= goal {recoverWhile=if_goal_recover}
private if_goal_recover ::= !(ELSEIF_KEYWORD | ELSE_KEYWORD | END_KEYWORD)

foreach_goal ::= goal {recoverWhile=foreach_goal_recover}
private foreach_goal_recover ::= !END_KEYWORD

foreach_body ::= foreach_goal END_KEYWORD

foreach_loop ::= FOREACH_KEYWORD LPAR foreach_items RPAR foreach_body {pin=2}

// foreach header items with recovery
foreach_items ::= iterator foreach_items_tail?
foreach_items_tail ::= COMMA (iterator | condition) foreach_items_tail? {pin=1 recoverWhile=foreach_items_recover}
private foreach_items_recover ::= !RPAR

while_loop ::= WHILE_KEYWORD LPAR while_condition RPAR [LOOP_KEYWORD] while_body END_KEYWORD {pin=1}
while_condition ::= goal {recoverWhile=while_condition_recover}
private while_condition_recover ::= !RPAR
while_body ::= goal {recoverWhile=while_body_recover}
private while_body_recover ::= !END_KEYWORD

loop_while ::= LOOP_KEYWORD loop_body WHILE_KEYWORD LPAR loop_condition RPAR {pin=1}
loop_body ::= goal {recoverWhile=loop_body_recover}
private loop_body_recover ::= !WHILE_KEYWORD
loop_condition ::= goal {recoverWhile=loop_condition_recover}
private loop_condition_recover ::= !RPAR

try_catch ::= TRY_KEYWORD try_body catch_clause* [FINALLY_KEYWORD finally_body] END_KEYWORD {pin=1}
try_body ::= goal {recoverWhile=try_body_recover}
private try_body_recover ::= !(CATCH_KEYWORD | FINALLY_KEYWORD | END_KEYWORD)
finally_body ::= goal {recoverWhile=finally_body_recover}
private finally_body_recover ::= !END_KEYWORD

catch_clause ::= CATCH_KEYWORD LPAR catch_pattern_content RPAR catch_body {pin=1}
catch_pattern_content ::= exception_pattern {recoverWhile=catch_pattern_recover}
private catch_pattern_recover ::= !RPAR
catch_body ::= goal {recoverWhile=catch_body_recover}
private catch_body_recover ::= !(CATCH_KEYWORD | FINALLY_KEYWORD | END_KEYWORD)

exception_pattern ::= term

throw_statement ::= THROW_KEYWORD LPAR throw_content RPAR {pin=1}
throw_content ::= argument {recoverWhile=throw_recover}
private throw_recover ::= !RPAR

expression_with_relations ::= expression (bin_rel_op expression)*

bin_rel_op ::= EQUAL | NOT_EQUAL | ASSIGN_OP | NUMERICALLY_EQUAL | NUMERICALLY_NON_EQUAL | IDENTICAL | NOT_IDENTICAL | UNIV_OP | DOUBLE_COLON_OP
             | GREATER | GREATER_EQUAL | LESS | LESS_EQUAL | LESS_EQUAL_PROLOG
             | IN_KEYWORD | NOT_IN_KEYWORD | IS_KEYWORD | HASH_LESS_EQUAL_ALT_OP | HASH_LESS_EQUAL_OP | HASH_GREATER_EQUAL_OP
             | HASH_EQUAL_OP | HASH_NOT_EQUAL_OP | HASH_GREATER_OP | HASH_LESS_OP
             | AT_LESS_EQUAL_OP | AT_GREATER_EQUAL_OP
             | AT_GREATER_OP | AT_LESS_OP | AT_LESS_EQUAL_PROLOG_OP
             | NOT_UNIFIABLE_OP | NOT_IDENTICAL_PROLOG_OP

// === Arguments & Expressions ===
argument ::= expression_with_relations

expression ::= range_expr

range_expr ::= or_expr [RANGE_OP or_expr [RANGE_OP or_expr]]

or_expr ::= xor_expr (BITWISE_OR xor_expr)*

xor_expr ::= and_expr (BITWISE_XOR and_expr)*

and_expr ::= shift_expr (BITWISE_AND shift_expr)*

shift_expr ::= additive_expr ((SHIFT_LEFT | SHIFT_RIGHT | SHIFT_RIGHT_TRIPLE) additive_expr)*

additive_expr ::= multiplicative_expr ((PLUS | CONCAT_OP | MINUS) multiplicative_expr)*

multiplicative_expr ::= unary_expr ((MULTIPLY | DIVIDE | INT_DIVIDE | DIV_RIGHT | DIV_LEFT | DIV_KEYWORD | MOD_KEYWORD | REM_KEYWORD) unary_expr)*

unary_expr ::= power_expr
             | PLUS unary_expr
             | MINUS unary_expr
             | COMPLEMENT unary_expr

power_expr ::= primary_expr [POWER unary_expr]

primary_expr ::= base_expr postfix_ops?

postfix_ops ::= postfix_op postfix_ops?

postfix_op ::= dot_access | index_access

dot_access ::= (DOT_IDENTIFIER | DOT_SINGLE_QUOTED_ATOM) [LPAR dot_access_inner RPAR]
private dot_access_inner ::= [argument (COMMA argument)*] {recoverWhile=dot_access_recover}
private dot_access_recover ::= !RPAR

index_access ::= LBRACKET index_access_inner RBRACKET
private index_access_inner ::= argument (COMMA argument)* {recoverWhile=index_access_recover}
private index_access_recover ::= !RBRACKET

base_expr ::= function_call
            | function_call_no_dot
            | parenthesized_goal
            | lambda_term
            | term_constructor
            | as_pattern
            | list_expr
            | array_expr
            | STRING
            | VARIABLE
            | INTEGER
            | FLOAT
            | TRUE
            | FALSE
            | atom_no_args

atom_no_args ::= atom !LPAR

parenthesized_goal ::= LPAR parenthesized_goal_content RPAR {pin=1}
parenthesized_goal_content ::= goal {recoverWhile=parenthesized_goal_recover}
private parenthesized_goal_recover ::= !RPAR

type_annotation ::= VARIABLE DOUBLE_COLON_OP expression

as_pattern ::= VARIABLE AT term [AT]

list_expr ::= list_expr_comprehension | list_expr_standard | list_expr_empty

list_expr_comprehension ::= LBRACKET argument COLON iterator list_comprehension_tail? RBRACKET

list_expr_standard ::= LBRACKET argument !COLON list_items_tail? [PIPE argument] RBRACKET

list_expr_empty ::= LBRACKET RBRACKET

list_comprehension_tail ::= COMMA (iterator | condition) list_comprehension_tail? {pin=1 recoverWhile=list_comp_recover}

list_items_tail ::= COMMA argument list_items_tail? {pin=1 recoverWhile=list_items_recover}

array_expr ::= array_expr_comprehension | array_expr_standard | array_expr_empty

array_expr_comprehension ::= LBRACE argument COLON iterator array_comprehension_tail? RBRACE

array_expr_standard ::= LBRACE argument !COLON array_items_tail? RBRACE

array_expr_empty ::= LBRACE RBRACE

array_comprehension_tail ::= COMMA (iterator | condition) array_comprehension_tail? {pin=1 recoverWhile=array_comp_recover}

array_items_tail ::= COMMA argument array_items_tail? {pin=1 recoverWhile=array_items_recover}

lambda_term ::= LAMBDA_KEYWORD LPAR variable_list COMMA argument RPAR

variable_list ::= LBRACKET [VARIABLE variable_list_tail?] RBRACKET

variable_list_tail ::= COMMA VARIABLE variable_list_tail? {pin=1 recoverWhile=var_list_recover}

term_constructor ::= DOLLAR expression | IDENTIFIER LPAR [argument argument_list_tail?] RPAR

argument_list_tail ::= COMMA argument argument_list_tail? {pin=1 recoverWhile=args_recover}

// === Iterators ===
iterator ::= term IN_KEYWORD expression
           | term EQUAL expression

// === Terms (general) ===
term ::= LPAR term RPAR
       | variable_as_pattern
       | INTEGER
       | FLOAT
       | TRUE
       | FALSE
       | STRING
       | VARIABLE
       | atom_or_call_no_lambda
       | list_expr_no_comprehension
       | array_expr
       | function_call_no_dot
       | term_constructor

variable_as_pattern ::= VARIABLE AT term [AT]

atom_or_call_no_lambda ::= atom [LPAR [argument argument_list_tail?] RPAR] {pin=2}

list_expr_no_comprehension ::= LBRACKET [term term_list_tail?] [PIPE term] RBRACKET

qualified_function_call ::= IDENTIFIER DOLLAR IDENTIFIER LPAR [argument argument_list_tail?] RPAR

function_call_simple ::= atom LPAR [argument argument_list_tail?] RPAR {pin=2}
private function_call_recover ::= !(RPAR | COMMA | PLUS | CONCAT_OP | DOT | THEN_KEYWORD | ELSEIF_KEYWORD | ELSE_KEYWORD | END_KEYWORD | ARROW_OP | BACKTRACKABLE_ARROW_OP | PROLOG_RULE_OP | SEMICOLON | OR_OR | RBRACKET | RBRACE)
function_call ::= function_call_simple | qualified_function_call

function_argument ::= expression_with_relations

function_call_no_dot_simple ::= atom LPAR [argument argument_list_tail?] RPAR {pin=2}
private function_call_no_dot_recover ::= !(RPAR | COMMA | PLUS | CONCAT_OP | DOT | THEN_KEYWORD | ELSEIF_KEYWORD | ELSE_KEYWORD | END_KEYWORD | ARROW_OP | BACKTRACKABLE_ARROW_OP | PROLOG_RULE_OP | SEMICOLON | OR_OR | RBRACKET | RBRACE)
function_call_no_dot ::= function_call_no_dot_simple | IDENTIFIER DOLLAR IDENTIFIER LPAR [argument argument_list_tail?] RPAR {pin=4}

function_argument_list_tail ::= COMMA function_argument function_argument_list_tail? {pin=1 recoverWhile=args_recover}

term_list_tail ::= COMMA term term_list_tail? {pin=1 recoverWhile=term_list_recover}

atom ::= IDENTIFIER | QUALIFIED_ATOM | SINGLE_QUOTED_ATOM | dollar_escaped_atom | MIN | MAX | CATCH_KEYWORD | THROW_KEYWORD | DIV_KEYWORD | MOD_KEYWORD | REM_KEYWORD | FAIL_KEYWORD | REPEAT_KEYWORD | ONCE_KEYWORD | NOT_KEYWORD | IS_KEYWORD | TRUE | FALSE {implements="com.github.avrilfanomar.picatplugin.language.references.PicatNameIdentifierOwner" mixin="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatAtomMixin" methods=["getName" "setName" "getNameIdentifier"]}

dollar_escaped_atom ::= DOLLAR IDENTIFIER


// === Recovery predicates ===
private list_items_recover ::= !(RBRACKET | PIPE)
private array_items_recover ::= !RBRACE
private array_comp_recover ::= !RBRACE
private list_comp_recover ::= !(RBRACKET | PIPE)
private args_recover ::= !RPAR
private term_list_recover ::= !(RPAR | RBRACKET | PIPE)
private var_list_recover ::= !RBRACKET
private conjunction_recover ::= !(SEMICOLON | OR_OR | IF_THEN_OP | RPAR | RBRACKET | RBRACE | DOT | THEN_KEYWORD | ELSEIF_KEYWORD | ELSE_KEYWORD | END_KEYWORD | ARROW_OP | BACKTRACKABLE_ARROW_OP | PROLOG_RULE_OP)
