{
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  parserClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParser"
  psiClassPrefix="Picat"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.avrilfanomar.picatplugin.language.psi"
  psiImplPackage="com.github.avrilfanomar.picatplugin.language.psi.impl"

  elementTypeHolderClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenTypes"
  elementTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatElementType"
  tokenTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenType"

  tokens = [
    // Keywords
    MODULE_KEYWORD="module"
    END_MODULE_KEYWORD="end_module"
    IMPORT_KEYWORD="import"
    EXPORT_KEYWORD="export"
    INCLUDE_KEYWORD="include"
    IF_KEYWORD="if"
    THEN_KEYWORD="then"
    ELSEIF_KEYWORD="elseif"
    ELSE_KEYWORD="else"
    END_KEYWORD="end"
    FOREACH_KEYWORD="foreach"
    IN_KEYWORD="in"
    LOOP_KEYWORD="loop"
    PRIVATE_KEYWORD="private"
    TABLE_KEYWORD="table"
    INDEX_KEYWORD="index"
    RETURN_KEYWORD="return"
    CONTINUE_KEYWORD="continue"
    BREAK_KEYWORD="break"
    NOT_KEYWORD="not"
    FAIL_KEYWORD="fail"
    TRUE_KEYWORD="true"
    FALSE_KEYWORD="false"
    CASE_KEYWORD="case"
    OF_KEYWORD="of"
    TRY_KEYWORD="try"
    CATCH_KEYWORD="catch"
    FINALLY_KEYWORD="finally"
    THROW_KEYWORD="throw"
    USING_KEYWORD="using"
    WHILE_KEYWORD="while"
    DO_KEYWORD="do"
    PASS_KEYWORD="pass"

    // Operators
    ARROW_OP="=>"
    BACKTRACKABLE_ARROW_OP="?=>"
    BICONDITIONAL_OP="<=>"
    BACKTRACKABLE_BICONDITIONAL_OP="?<=>"
    HASH_BICONDITIONAL_OP="#<=>"
    HASH_ARROW_OP="#=>"
    HASH_OR_OP="#\\/"
    HASH_CARET_OP="#^"
    HASH_AND_OP="#/\\"
    HASH_TILDE_OP="#~"
    RULE_OP=":-"
    ASSIGN_OP=":="
    RANGE_OP=".."
    EQUAL="="
    NOT_EQUAL="!="
    LESS="<"
    GREATER=">"
    LESS_EQUAL="<="
    GREATER_EQUAL=">="
    IDENTICAL="=:="
    NOT_IDENTICAL="=\\="
    PLUS="+"
    MINUS="-"
    MULTIPLY="*"
    POWER="**"
    DIVIDE="/"
    INT_DIVIDE="//"
    DIV_KEYWORD="div"
    REM_KEYWORD="rem"
    MOD_KEYWORD="mod"
    SHIFT_LEFT="<<"
    SHIFT_RIGHT=">>"
    SHIFT_RIGHT_TRIPLE_OP=">>>"
    BACKSLASH="\\"
    AND_KEYWORD="and"
    OR_KEYWORD="or"
    XOR_KEYWORD="xor"
    CARET="^"
    AMPERSAND="&"
    PIPE="|"
    IS_KEYWORD="is"
    CONCAT_OP="++"

    // Separators
    DOT="."
    COMMA=","
    SEMICOLON=";"
    COLON=":"
    LPAR="("
    RPAR=")"
    LBRACKET="["
    RBRACKET="]"
    LBRACE="{"
    RBRACE="}"
    CUT="!"
    AT="@"

    // Literals (expanded)
    IDENTIFIER="regexp:[a-z][a-zA-Z0-9_]*"
    VARIABLE="regexp:[A-Z][a-zA-Z0-9_]*"
    ANONYMOUS_VARIABLE="regexp:_[a-zA-Z0-9_]*"
    INTEGER="regexp:[0-9]+"
    HEX_INTEGER="regexp:0[xX][0-9a-fA-F]+"
    OCTAL_INTEGER="regexp:0[oO][0-7]+"
    BINARY_INTEGER="regexp:0[bB][01]+"
    FLOAT="regexp:[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?"
    STRING="regexp:\"([^\"\\]|\\.)*\""
    QUOTED_ATOM="regexp:'([^'\\]|\\.)*'"
    COMMENT="regexp:%[^\r\n]*"
    MULTI_LINE_COMMENT="regexp:/\*([^*]|\*+[^*/])*\*+/"
  ]
}

// Root rule
picatFile ::= (item_*)? // Explicitly make the whole sequence of items optional

// Removed picat_file_content rule

item_ ::= (function_clause | predicate_clause | general_directive | COMMENT | MULTI_LINE_COMMENT) {elementType=ITEM}


// Module declaration
module_decl ::= module_declaration end_module_declaration? {elementType=MODULE_DECLARATION}
module_declaration ::= MODULE_KEYWORD module_name [export_clause] [import_clause] DOT { pin=1 elementType=MODULE_DECLARATION_CONTENT} // Retaining this for potential distinct PSI if module_decl is just a wrapper
end_module_declaration ::= END_MODULE_KEYWORD [module_name] DOT { pin=1 elementType=END_MODULE_DECLARATION }
module_name ::= atom {elementType=MODULE_NAME}

export_clause ::= EXPORT_KEYWORD export_list { pin=1 elementType=EXPORT_CLAUSE }
import_clause ::= IMPORT_KEYWORD import_list { pin=1 elementType=IMPORT_CLAUSE }

// Directives
general_directive ::= import_statement | export_statement | include_statement | using_statement | compilation_directive {elementType = DIRECTIVE}

compilation_directive ::= [PRIVATE_KEYWORD] (table_mode | index_mode) DOT {pin=1 elementType=COMPILATION_DIRECTIVE}
table_mode ::= TABLE_KEYWORD head_reference_list {elementType=TABLE_MODE}
index_mode ::= INDEX_KEYWORD head_reference_list [indexing_details] {elementType=INDEX_MODE}
head_reference_list ::= head_reference ((COMMA | SEMICOLON) head_reference)* {elementType=HEAD_REFERENCE_LIST}
head_reference ::= atom ('/' INTEGER)? {elementType=HEAD_REFERENCE}
indexing_details ::= LPAR argument_list RPAR {elementType=INDEXING_DETAILS}


import_statement ::= IMPORT_KEYWORD import_list DOT { pin=1 elementType=IMPORT_STATEMENT}
export_statement ::= EXPORT_KEYWORD export_list DOT { pin=1 elementType=EXPORT_STATEMENT}
include_statement ::= INCLUDE_KEYWORD file_spec DOT { pin=1 elementType=INCLUDE_STATEMENT}
using_statement ::= USING_KEYWORD module_name ["=>" rename_list] DOT { pin=1 elementType=USING_STATEMENT}

import_list ::= import_item (COMMA import_item)* {elementType=IMPORT_LIST}
import_item ::= module_name ["=>" rename_list] {elementType=IMPORT_ITEM}
rename_list ::= rename_spec (COMMA rename_spec)* {elementType=RENAME_LIST}
rename_spec ::= atom ["=>" atom] {elementType=RENAME_SPEC}

export_list ::= export_spec (COMMA export_spec)* {elementType=EXPORT_LIST}
export_spec ::= predicate_rule | atom {elementType=EXPORT_SPEC}

file_spec ::= STRING | atom {elementType=FILE_SPEC}

// Predicate Clauses
predicate_clause ::= predicate_rule | predicate_fact {elementType=PREDICATE_CLAUSE}

// Changed pin from 1 to 2, assuming RULE_OP (actual: rule_operator) is the commit point
predicate_rule ::= head rule_operator body DOT {pin=2 elementType = PREDICATE_RULE}
predicate_fact ::= head DOT {pin=1 elementType = PREDICATE_FACT}


// Function Clauses
function_clause ::= function_rule | function_fact {elementType=FUNCTION_CLAUSE}

function_rule ::= head EQUAL function_body DOT {pin=2 elementType = FUNCTION_RULE} // ASSIGN_OP changed to EQUAL
function_fact ::= head EQUAL expression DOT {pin=2 elementType = FUNCTION_FACT} // ASSIGN_OP changed to EQUAL

function_body ::= expression [rule_operator body]? {
  elementType = FUNCTION_BODY
}

// Actor Definition
actor_definition ::= [PRIVATE_KEYWORD] actor_name DOT (actor_member DOT)* END_KEYWORD DOT {elementType = ACTOR_DEFINITION}
actor_name ::= atom {elementType=ACTOR_NAME}
actor_member ::= action_rule | predicate_clause | function_clause | compilation_directive {elementType=ACTOR_MEMBER}
action_rule ::= head HASH_ARROW_OP body {elementType = ACTION_RULE}


rule_operator ::= ARROW_OP | BACKTRACKABLE_ARROW_OP | BICONDITIONAL_OP | BACKTRACKABLE_BICONDITIONAL_OP | RULE_OP {elementType=RULE_OPERATOR}

// Heads
head ::= structure | atom_no_args | qualified_atom {elementType=HEAD} // Reordered: structure first
qualified_atom ::= atom DOT atom {elementType=QUALIFIED_ATOM} // DOT was "."
atom_no_args ::= atom !LPAR {elementType=ATOM_NO_ARGS}

// Body
body ::= goal ((SEMICOLON | COMMA) goal)* {elementType=BODY recoverWhile=body_recover }
private body_recover ::= !(DOT | END_KEYWORD)

// Goals
goal ::= call  // Replaced predicate_fact with call to avoid consuming DOT within body
       | if_then_else
       | case_expression
       | try_catch
       | assignment
       | unification
       | comparison
       | arithmetic_comparison
       | negation
       | fail_goal
       | pass_goal
       | true_goal
       | false_goal
       | not_goal
       | foreach_loop
       | while_loop
       | loop_while_statement
       | list_comprehension_goal
       | procedure_call
       | cut_goal
       | return_stmt
       | continue_stmt
       | break_stmt
       | throw_stmt
       | expression
       {elementType=GOAL}

// Goal implementations
call ::= structure | atom
if_then_else ::= IF_KEYWORD expression THEN_KEYWORD body [elseif_clause] [ELSE_KEYWORD body] END_KEYWORD {elementType=IF_THEN_ELSE}
elseif_clause ::= ELSEIF_KEYWORD expression THEN_KEYWORD body [elseif_clause] {elementType=ELSEIF_CLAUSE}
assignment ::= variable ASSIGN_OP expression {elementType=ASSIGNMENT}
unification ::= expression EQUAL expression | expression NOT_EQUAL expression {elementType=UNIFICATION}
comparison ::= expression comparison_operator expression {elementType=COMPARISON}
comparison_operator ::= LESS | GREATER | LESS_EQUAL | GREATER_EQUAL
arithmetic_comparison ::= expression arithmetic_comparison_operator expression {elementType=ARITHMETIC_COMPARISON}
arithmetic_comparison_operator ::= IDENTICAL | NOT_IDENTICAL
negation ::= NOT_KEYWORD goal {elementType=NEGATION}
fail_goal ::= FAIL_KEYWORD {elementType=FAIL_GOAL}
pass_goal ::= PASS_KEYWORD {elementType=PASS_GOAL}
true_goal ::= TRUE_KEYWORD {elementType=TRUE_GOAL}
false_goal ::= FALSE_KEYWORD {elementType=FALSE_GOAL}
not_goal ::= negation
foreach_loop ::= FOREACH_KEYWORD LPAR foreach_generators RPAR body END_KEYWORD {
  elementType = FOREACH_LOOP
}
foreach_generators ::= foreach_generator (COMMA foreach_generator)* {elementType=FOREACH_GENERATORS}
foreach_generator ::= variable IN_KEYWORD expression | variable EQUAL expression {elementType=FOREACH_GENERATOR}
list_comprehension_goal ::= LBRACKET expression PIPE foreach_generators RBRACKET {elementType=LIST_COMPREHENSION_GOAL}
procedure_call ::= atom LPAR argument_list? RPAR {elementType=PROCEDURE_CALL} // Made argument_list optional here too based on function_call

cut_goal ::= CUT {elementType=CUT_GOAL}
return_stmt ::= RETURN_KEYWORD expression {elementType=RETURN_STMT}
continue_stmt ::= CONTINUE_KEYWORD {elementType=CONTINUE_STMT}
break_stmt ::= BREAK_KEYWORD {elementType=BREAK_STMT}
throw_stmt ::= THROW_KEYWORD expression {elementType=THROW_STMT}

// New control structures
case_expression ::= CASE_KEYWORD expression OF_KEYWORD case_arms END_KEYWORD {elementType=CASE_EXPRESSION}
case_arms ::= case_arm (SEMICOLON case_arm)* {elementType=CASE_ARMS}
case_arm ::= pattern ARROW_OP body {elementType=CASE_ARM}

try_catch ::= TRY_KEYWORD body CATCH_KEYWORD catch_clauses [FINALLY_KEYWORD body] END_KEYWORD {elementType=TRY_CATCH}
catch_clauses ::= catch_clause (SEMICOLON catch_clause)* {elementType=CATCH_CLAUSES}
catch_clause ::= pattern ARROW_OP body {elementType=CATCH_CLAUSE}

while_loop ::= WHILE_KEYWORD expression DO_KEYWORD body END_KEYWORD {
  elementType = WHILE_LOOP
}

loop_while_statement ::= LOOP_KEYWORD body WHILE_KEYWORD expression DOT {pin=1 elementType=LOOP_WHILE_STATEMENT}


// Patterns
pattern ::= variable | atom | number | ANONYMOUS_VARIABLE | structure_pattern | list_pattern | tuple_pattern {elementType=PATTERN}
structure_pattern ::= atom LPAR pattern_list? RPAR {elementType=STRUCTURE_PATTERN}
list_pattern ::= LBRACKET pattern_list? (PIPE pattern)? RBRACKET {elementType=LIST_PATTERN}
tuple_pattern ::= LBRACE pattern_list? RBRACE {elementType=TUPLE_PATTERN}
pattern_list ::= pattern (COMMA pattern)* {elementType=PATTERN_LIST}

// Basic elements
atom ::= IDENTIFIER | QUOTED_ATOM {elementType=ATOM}
number ::= INTEGER | FLOAT | HEX_INTEGER | OCTAL_INTEGER | BINARY_INTEGER
structure ::= atom LPAR argument_list? RPAR { // Removed optional "$?"
  elementType = STRUCTURE
}
tuple ::= LBRACE tuple_items? RBRACE {elementType=TUPLE}
tuple_items ::= expression (COMMA expression)* {elementType=TUPLE_ITEMS}
argument_list ::= expression (COMMA expression)* {
  elementType=ARGUMENT_LIST
}

// Expressions
expression ::= biconditional_expression_level {
  elementType = EXPRESSION
}

biconditional_expression_level ::= implication_expression_level ((BICONDITIONAL_OP | HASH_BICONDITIONAL_OP | BACKTRACKABLE_BICONDITIONAL_OP) implication_expression_level)*
implication_expression_level ::= conditional_expression ((ARROW_OP | HASH_ARROW_OP | BACKTRACKABLE_ARROW_OP) conditional_expression)*
conditional_expression ::= logical_or_expression ("?" expression COLON expression)?

logical_or_expression ::= logical_and_expression ((OR_KEYWORD | HASH_OR_OP) logical_and_expression)*
logical_and_expression ::= bitwise_or_expression ((AND_KEYWORD | HASH_AND_OP) bitwise_or_expression)*

bitwise_or_expression ::= bitwise_xor_expression (PIPE bitwise_xor_expression)*
bitwise_xor_expression ::= bitwise_and_expression ((CARET | XOR_KEYWORD | HASH_CARET_OP) bitwise_and_expression)*
bitwise_and_expression ::= equality_expression (AMPERSAND equality_expression)*

equality_expression ::= relational_expression ((IDENTICAL | NOT_IDENTICAL) relational_expression)*
relational_expression ::= shift_expression ((LESS | GREATER | LESS_EQUAL | GREATER_EQUAL) shift_expression)*
shift_expression ::= additive_expression ((SHIFT_LEFT | SHIFT_RIGHT | SHIFT_RIGHT_TRIPLE_OP) additive_expression)*
additive_expression ::= multiplicative_expression ((PLUS | MINUS) multiplicative_expression)*
multiplicative_expression ::= power_expression ((MULTIPLY | DIVIDE | INT_DIVIDE | MOD_KEYWORD | DIV_KEYWORD | REM_KEYWORD) power_expression)*
power_expression ::= unary_expression (POWER unary_expression)*

unary_expression ::= ((PLUS | MINUS | NOT_KEYWORD | BACKSLASH | HASH_TILDE_OP) primary_expression) | primary_expression {elementType=UNARY_EXPRESSION}

primary_expression ::=
    // Compound forms starting with atom/variable first
    function_call                 // atom LPAR ...
  | term_constructor_expression   // atom LBRACE ...
  | index_access_expression       // variable LBRACKET ...
  | as_pattern_expression         // variable AT pattern (starts with variable, but pattern is more specific)
    // Simpler forms later
  | atom
  | number
  | variable
  | ANONYMOUS_VARIABLE
  | list_expression
  | list_pattern
  | structure_pattern
  | tuple_pattern
  | tuple
  | map
  | lambda_expression
  | list_comprehension_expression
  | dollar_term_constructor
  | LPAR expression RPAR

dollar_term_constructor ::= "$" goal "$" {elementType=DOLLAR_TERM_CONSTRUCTOR}

index_access_expression ::= variable LBRACKET expression (COMMA expression)? RBRACKET {elementType=INDEX_ACCESS_EXPRESSION}

as_pattern_expression ::= variable AT pattern AT? {elementType=AS_PATTERN_EXPRESSION}

lambda_expression ::= LBRACE variable_list? RBRACE ARROW_OP (expression | body) {elementType=LAMBDA_EXPRESSION}
variable_list ::= variable (COMMA variable)* {elementType=VARIABLE_LIST}

term_constructor_expression ::= (atom | qualified_atom) LBRACE map_entries RBRACE {elementType=TERM_CONSTRUCTOR_EXPRESSION}


// Function Calls
function_call ::= atom LPAR argument_list? RPAR | builtin_call {elementType=FUNCTION_CALL}
builtin_call ::= builtin_name LPAR argument_list? RPAR
builtin_name ::= "call" | "apply" | "new_struct" | "new_map"


// List and Array Expressions
list_expression ::= LBRACKET list_items? RBRACKET {
  elementType = LIST_EXPRESSION
}
list_items ::= expression ((COMMA | SEMICOLON) expression)* (PIPE expression)? {elementType = LIST_ELEMENTS}
list_comprehension_expression ::= LBRACKET expression PIPE foreach_generators RBRACKET {elementType=LIST_COMPREHENSION_EXPRESSION}

// Operators
operator ::= PLUS | MINUS | MULTIPLY | DIVIDE | MOD_KEYWORD | POWER | SHIFT_LEFT | SHIFT_RIGHT | SHIFT_RIGHT_TRIPLE_OP |
             BACKSLASH | INT_DIVIDE | DIV_KEYWORD | REM_KEYWORD |
             AND_KEYWORD | OR_KEYWORD | XOR_KEYWORD | CARET | AMPERSAND | PIPE | IS_KEYWORD |
             HASH_AND_OP | HASH_OR_OP | HASH_CARET_OP | HASH_TILDE_OP | HASH_ARROW_OP | HASH_BICONDITIONAL_OP


// Maps
map ::= LBRACE map_entries? RBRACE {elementType=MAP}
map_entries ::= map_entry (COMMA map_entry)* {elementType=MAP_ENTRIES}
map_entry ::= expression COLON expression {elementType=MAP_ENTRY}
