{
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  parserClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParser"
  parserUtilClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParserUtil"
  psiClassPrefix="Picat"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.avrilfanomar.picatplugin.language.psi"
  psiImplPackage="com.github.avrilfanomar.picatplugin.language.psi.impl"

  elementTypeHolderClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenTypes"
  elementTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatElementType"
  tokenTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenType"

  tokens = [
    // Keywords
    MODULE_KEYWORD="module"
    IMPORT_KEYWORD="import"
    INCLUDE_KEYWORD="include"
    PRIVATE_KEYWORD="private"
    TABLE_KEYWORD="table"
    INDEX_KEYWORD="index"
    IF_KEYWORD="if"
    THEN_KEYWORD="then"
    ELSEIF_KEYWORD="elseif"
    ELSE_KEYWORD="else"
    END_KEYWORD="end"
    FOREACH_KEYWORD="foreach"
    IN_KEYWORD="in"
    WHILE_KEYWORD="while"
    LOOP_KEYWORD="loop"
    TRY_KEYWORD="try"
    CATCH_KEYWORD="catch"
    FINALLY_KEYWORD="finally"
    NOT_KEYWORD="not"
    DIV_KEYWORD="div"
    MOD_KEYWORD="mod"
    REM_KEYWORD="rem"
    LAMBDA_KEYWORD="lambda"
    CARDINALITY_KEYWORD="cardinality"
    FAIL_KEYWORD="fail"
    REPEAT_KEYWORD="repeat"
    UNTIL_KEYWORD="until"

    // Operators
    SHIFT_RIGHT_TRIPLE=">>>"
    BACKTRACKABLE_ARROW_OP="?=>"
    BICONDITIONAL_OP="<=>"
    HASH_BICONDITIONAL_OP="#<=>"
    HASH_NOT_EQUAL_OP="#!="
    HASH_ARROW_OP="#=>"
    HASH_GREATER_EQUAL_OP="#>="
    HASH_LESS_EQUAL_OP="#=<"
    HASH_LESS_EQUAL_ALT_OP="#<="
    AT_GREATER_EQUAL_OP="@>="
    AT_LESS_EQUAL_OP="@<="
    AT_LESS_EQUAL_PROLOG_OP="@=<"
    NUMERICALLY_EQUAL="=:="
    NUMERICALLY_NON_EQUAL="=\="
    NOT_IDENTICAL="!=="
    HASH_OR_OP="#\/"
    HASH_XOR_OP="#^"
    HASH_AND_OP='#\'
    ARROW_OP="=>"
    HASH_NOT_OP="#~"
    HASH_EQUAL_OP="#="
    HASH_GREATER_OP="#>"
    HASH_LESS_OP="#<"
    AT_GREATER_OP="@>"
    AT_LESS_OP="@<"
    ASSIGN_OP=":="
    DOUBLE_COLON_OP="::"
    RANGE_OP=".."
    NOT_EQUAL="!="
    IDENTICAL="=="
    GREATER=">"
    LESS_EQUAL="<="
    GREATER_EQUAL=">="
    LESS_EQUAL_PROLOG="=<"
    DIV_RIGHT="/>"
    DIV_LEFT="/<"
    POWER="**"
    PROLOG_RULE_OP=":-"
    CONCAT_OP="++"
    SHIFT_LEFT="<<"
    SHIFT_RIGHT=">>"
    INT_DIVIDE="//"
    BITWISE_AND='/\'
    BITWISE_OR="\/"
    DIVIDE="/"
    EQUAL="="
    LESS="<"
    PLUS="+"
    MINUS="-"
    MIN="min"
    MAX="max"
    NT="nt"
    MULTIPLY="*"
    BITWISE_XOR="^"
    COMPLEMENT="~"
    EXCLAMATION="!"

    // Separators
    DOT="."
    COMMA=","
    SEMICOLON=";"
    COLON=":"
    LPAR="("
    RPAR=")"
    LBRACKET="["
    RBRACKET="]"
    LBRACE="{"
    RBRACE="}"
    PIPE="|"
    AT="@"
    DOLLAR="$"

    // Literals
    IDENTIFIER="regexp:[a-z][a-zA-Z0-9_]*"
    DOT_IDENTIFIER="regexp:\\.[a-z][a-zA-Z0-9_]*"
    VARIABLE="regexp:[A-Z_][a-zA-Z0-9_]*"
    INTEGER="regexp:([0-9]+|0[xX][0-9a-fA-F]+|0[oO][0-7]+|0[bB][01]+)"
    FLOAT="regexp:[0-9]+\\.[0-9]+([eE][+-]?[0-9]+)?"
    STRING="regexp:\"(\\.|[^\"\\])*\""
    SINGLE_QUOTED_ATOM="regexp:'([^'\\]|\\.)*'"
    DOT_SINGLE_QUOTED_ATOM="regexp:\\.'([^'\\]|\\.)*'"
    COMMENT="regexp:%.*"
    QUALIFIED_ATOM="regexp:[a-z][a-zA-Z0-9_]*\\.[a-z][a-zA-Z0-9_]*"
    MULTILINE_COMMENT="regexp:/[*]([^*]|[*][^/])*[*]/"
    TRUE="true"
    FALSE="false"
  ]
}

// === Root ===
program ::= program_item*

program_item ::= MULTILINE_COMMENT
               | module_declaration
               | import_declaration
               | include_declaration
               | predicate_definition
               | function_definition
               | actor_definition

// === Module & Imports ===
module_declaration ::= MODULE_KEYWORD atom DOT {pin=1}

import_declaration ::= IMPORT_KEYWORD import_item (COMMA import_item)* DOT {pin=1}

import_item ::= (atom | QUALIFIED_ATOM) [DIV_RIGHT INTEGER]

include_declaration ::= INCLUDE_KEYWORD STRING (COMMA STRING)* DOT {pin=1}

// === Predicate and Function Definitions ===
predicate_definition ::= predicate_directive* predicate_clause

predicate_clause ::= predicate_rule | predicate_fact

predicate_rule ::= head [COMMA condition] (ARROW_OP | BACKTRACKABLE_ARROW_OP | PROLOG_RULE_OP) body DOT {pin=3}

predicate_fact ::= head DOT {pin=2}

function_definition ::= function_directive* function_clause

function_clause ::= function_rule | function_fact

function_rule ::= head EQUAL argument [COMMA condition] ARROW_OP body DOT {pin=5}

function_fact ::= head EQUAL argument DOT

// === Actor Definitions ===
actor_definition ::= [PRIVATE_KEYWORD] action_rule (action_rule | nonbacktrackable_predicate_rule)*

action_rule ::= head [COMMA condition] COMMA LBRACE event_pattern RBRACE ARROW_OP body DOT

nonbacktrackable_predicate_rule ::= head [COMMA condition] ARROW_OP body DOT

event_pattern ::= term (COMMA term)*

// === Directives ===
function_directive ::= PRIVATE_KEYWORD | TABLE_KEYWORD

predicate_directive ::= PRIVATE_KEYWORD
                     | TABLE_KEYWORD [LPAR table_mode (COMMA table_mode)* RPAR]
                     | INDEX_KEYWORD (LPAR index_mode (COMMA index_mode)* RPAR)+

index_mode ::= PLUS | MINUS
table_mode ::= PLUS | MINUS | MIN | MAX | NT

// === Heads ===
head ::= atom [LPAR [argument (COMMA argument)*] RPAR]

// === Conditions & Bodies ===
condition ::= goal
body ::= goal

// === Goal (Expressions and Control) ===
goal ::= disjunction

disjunction ::= conjunction (SEMICOLON conjunction)*

conjunction ::= negation (COMMA negation)*

negation ::= NOT_KEYWORD negation | equivalence

equivalence ::= implication (HASH_BICONDITIONAL_OP implication)*

implication ::= disjunction_or (HASH_ARROW_OP disjunction_or)*

disjunction_or ::= exclusive_or (HASH_OR_OP exclusive_or)*

exclusive_or ::= conjunction_and (HASH_XOR_OP conjunction_and)*

conjunction_and ::= negated (HASH_AND_OP negated)*

negated ::= HASH_NOT_OP negated | enclosed_goal

// Control structures and annotated expressions
enclosed_goal ::= if_then_else
                | foreach_loop
                | while_loop
                | loop_while
                | try_catch
                | type_annotation
                | expression_with_relations

if_then_else ::= IF_KEYWORD goal THEN_KEYWORD goal (ELSEIF_KEYWORD goal THEN_KEYWORD goal)* (ELSE_KEYWORD goal)? END_KEYWORD

foreach_loop ::= FOREACH_KEYWORD LPAR iterator (COMMA (iterator | condition))* RPAR goal END_KEYWORD

while_loop ::= WHILE_KEYWORD LPAR goal RPAR [LOOP_KEYWORD] goal END_KEYWORD

loop_while ::= LOOP_KEYWORD goal WHILE_KEYWORD LPAR goal RPAR

try_catch ::= TRY_KEYWORD goal catch_clause* [FINALLY_KEYWORD goal] END_KEYWORD

catch_clause ::= CATCH_KEYWORD LPAR exception_pattern RPAR goal

exception_pattern ::= term

expression_with_relations ::= expression (bin_rel_op expression)*

bin_rel_op ::= EQUAL | NOT_EQUAL | ASSIGN_OP | NUMERICALLY_EQUAL | NUMERICALLY_NON_EQUAL | IDENTICAL | NOT_IDENTICAL
             | GREATER | GREATER_EQUAL | LESS | LESS_EQUAL | LESS_EQUAL_PROLOG
             | IN_KEYWORD | HASH_LESS_EQUAL_ALT_OP | HASH_LESS_EQUAL_OP | HASH_GREATER_EQUAL_OP
             | HASH_EQUAL_OP | HASH_NOT_EQUAL_OP | HASH_GREATER_OP | HASH_LESS_OP
             | AT_LESS_EQUAL_OP | AT_GREATER_EQUAL_OP
             | AT_GREATER_OP | AT_LESS_OP | AT_LESS_EQUAL_PROLOG_OP

// === Arguments & Expressions ===
argument ::= expression

expression ::= range_expr

range_expr ::= or_expr [RANGE_OP or_expr [RANGE_OP or_expr]]

or_expr ::= xor_expr (BITWISE_OR xor_expr)*

xor_expr ::= and_expr (BITWISE_XOR and_expr)*

and_expr ::= shift_expr (BITWISE_AND shift_expr)*

shift_expr ::= additive_expr ((SHIFT_LEFT | SHIFT_RIGHT | SHIFT_RIGHT_TRIPLE) additive_expr)*

additive_expr ::= multiplicative_expr ((PLUS | CONCAT_OP | MINUS) multiplicative_expr)*

multiplicative_expr ::= unary_expr ((MULTIPLY | DIVIDE | INT_DIVIDE | DIV_RIGHT | DIV_LEFT | DIV_KEYWORD | MOD_KEYWORD | REM_KEYWORD) unary_expr)*

unary_expr ::= power_expr
             | PLUS unary_expr
             | MINUS unary_expr
             | COMPLEMENT unary_expr

power_expr ::= primary_expr [POWER unary_expr]

primary_expr ::= base_expr postfix_ops?

postfix_ops ::= postfix_op postfix_ops?

postfix_op ::= dot_access

dot_access ::= DOT_IDENTIFIER | DOT_SINGLE_QUOTED_ATOM [LPAR [argument (COMMA argument)*] RPAR]

base_expr ::= parenthesized_goal
            | lambda_term
            | function_call
            | term_constructor
            | as_pattern
            | list_expr
            | variable_index
            | array_expr
            | STRING
            | VARIABLE
            | INTEGER
            | FLOAT
            | TRUE
            | FALSE
            | atom_no_args

atom_no_args ::= atom !LPAR

parenthesized_goal ::= LPAR goal RPAR

type_annotation ::= VARIABLE DOUBLE_COLON_OP expression

variable_index ::= VARIABLE LBRACKET argument (COMMA argument)* RBRACKET

as_pattern ::= VARIABLE AT term [AT]

list_expr ::= LBRACKET [argument list_expr_suffix?] RBRACKET

list_expr_suffix ::= COLON iterator list_comprehension_tail?  // list comprehension
                   | list_items_tail? [PIPE argument]          // standard list tail

list_comprehension_tail ::= COMMA (iterator | condition) list_comprehension_tail?

list_items_tail ::= COMMA argument list_items_tail?

array_expr ::= LBRACE [argument array_items_tail?] RBRACE

array_items_tail ::= COMMA argument array_items_tail?

lambda_term ::= LAMBDA_KEYWORD LPAR variable_list COMMA argument RPAR

variable_list ::= LBRACKET [VARIABLE variable_list_tail?] RBRACKET

variable_list_tail ::= COMMA VARIABLE variable_list_tail?

term_constructor ::= DOLLAR expression | IDENTIFIER LPAR [argument argument_list_tail?] RPAR

argument_list_tail ::= COMMA argument argument_list_tail?

// === Iterators ===
iterator ::= term IN_KEYWORD expression
           | term EQUAL expression

// === Terms (general) ===
term ::= LPAR term RPAR
       | variable_as_pattern
       | INTEGER
       | FLOAT
       | TRUE
       | FALSE
       | VARIABLE
       | atom_or_call_no_lambda
       | list_expr_no_comprehension
       | array_expr
       | function_call_no_dot
       | term_constructor

variable_as_pattern ::= VARIABLE AT term [AT]

atom_or_call_no_lambda ::= atom [LPAR [term term_list_tail?] RPAR]

list_expr_no_comprehension ::= LBRACKET [term term_list_tail?] [PIPE term] RBRACKET

qualified_function_call ::= IDENTIFIER DOLLAR IDENTIFIER LPAR [function_argument function_argument_list_tail?] RPAR

function_call ::= atom LPAR [function_argument function_argument_list_tail?] RPAR
               | qualified_function_call

function_argument ::= expression_with_relations

function_call_no_dot ::= atom LPAR [term term_list_tail?] RPAR
                       | IDENTIFIER DOLLAR IDENTIFIER LPAR [term term_list_tail?] RPAR

function_argument_list_tail ::= COMMA function_argument function_argument_list_tail?

term_list_tail ::= COMMA term term_list_tail?

atom ::= IDENTIFIER | SINGLE_QUOTED_ATOM | dollar_escaped_atom | MIN | MAX

dollar_escaped_atom ::= DOLLAR IDENTIFIER
