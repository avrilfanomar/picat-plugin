{
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  parserClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParser"
  parserUtilClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParserUtil"
  psiClassPrefix="Picat"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.avrilfanomar.picatplugin.language.psi"
  psiImplPackage="com.github.avrilfanomar.picatplugin.language.psi.impl"

  elementTypeHolderClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenTypes"
  elementTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatElementType"
  tokenTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenType"

  tokens = [
    // Keywords
    MODULE_KEYWORD="module"
    END_MODULE_KEYWORD="end_module"
    IMPORT_KEYWORD="import"
    EXPORT_KEYWORD="export"
    INCLUDE_KEYWORD="include"
    IF_KEYWORD="if"
    THEN_KEYWORD="then"
    ELSEIF_KEYWORD="elseif"
    ELSE_KEYWORD="else"
    END_KEYWORD="end"
    FOREACH_KEYWORD="foreach"
    IN_KEYWORD="in"
    LOOP_KEYWORD="loop"
    PRIVATE_KEYWORD="private"
    TABLE_KEYWORD="table"
    INDEX_KEYWORD="index"
    RETURN_KEYWORD="return"
    CONTINUE_KEYWORD="continue"
    BREAK_KEYWORD="break"
    NOT_KEYWORD="not"
    FAIL_KEYWORD="fail"
    TRUE_KEYWORD="true"
    FALSE_KEYWORD="false"
    CASE_KEYWORD="case"
    OF_KEYWORD="of"
    TRY_KEYWORD="try"
    CATCH_KEYWORD="catch"
    FINALLY_KEYWORD="finally"
    THROW_KEYWORD="throw"
    USING_KEYWORD="using"
    WHILE_KEYWORD="while"
    DO_KEYWORD="do"
    PASS_KEYWORD="pass"

    // Operators
    ARROW_OP="=>"
    BACKTRACKABLE_ARROW_OP="?=>"
    BICONDITIONAL_OP="<=>"
    BACKTRACKABLE_BICONDITIONAL_OP="?<=>"
    HASH_BICONDITIONAL_OP="#<=>"
    HASH_ARROW_OP="#=>"
    HASH_OR_OP="#\\/"
    HASH_CARET_OP="#^"
    HASH_AND_OP="#/\\"
    HASH_TILDE_OP="#~"
    HASH_EQUAL_OP="#="
    HASH_LESS_EQUAL_OP="#=<"
    RULE_OP=":-"
    ASSIGN_OP=":="
    RANGE_OP=".."
    EQUAL="="
    NOT_EQUAL="!="
    HASH_NOT_EQUAL_OP="#!="
    LESS="<"
    GREATER=">"
    LESS_EQUAL="<="
    GREATER_EQUAL=">="
    IDENTICAL="=:="
    NOT_IDENTICAL="=\\="
    PLUS="+"
    MINUS="-"
    MULTIPLY="*"
    POWER="**"
    DIVIDE="/"
    INT_DIVIDE="//"
    DIV_KEYWORD="div"
    REM_KEYWORD="rem"
    MOD_KEYWORD="mod"
    SHIFT_LEFT="<<"
    SHIFT_RIGHT=">>"
    SHIFT_RIGHT_TRIPLE_OP=">>>"
    BACKSLASH="\\"
    AND_KEYWORD="and"
    OR_KEYWORD="or"
    XOR_KEYWORD="xor"
    CARET="^"
    AMPERSAND="&"
    PIPE="|"
    IS_KEYWORD="is"
    CONCAT_OP="++"
    DOUBLE_COLON_OP="::"

    // Separators
    DOT="."
    COMMA=","
    SEMICOLON=";"
    COLON=":"
    LPAR="("
    RPAR=")"
    LBRACKET="["
    RBRACKET="]"
    LBRACE="{"
    RBRACE="}"
    CUT="!"
    AT="@"
    QUESTION_MARK="?"
    DOLLAR="$"

    // Literals
    IDENTIFIER="regexp:[a-z][a-zA-Z0-9_]*"
    VARIABLE="regexp:[A-Z_][a-zA-Z0-9_]*"
    FIELD_ACCESS="regexp:\.[a-z][a-zA-Z0-9_]*"
    INTEGER="regexp:[0-9]+"
    HEX_INTEGER="regexp:0[xX][0-9a-fA-F]+"
    OCTAL_INTEGER="regexp:0[oO][0-7]+"
    BINARY_INTEGER="regexp:0[bB][01]+"
    FLOAT="regexp:[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?"
    STRING="regexp:\"([^\"\\]|\\\\.)*\""
    QUOTED_ATOM="regexp:'([^'\\]|\\\\.)*'"
    COMMENT="regexp:%[^\r\n]*"
    MULTI_LINE_COMMENT="regexp:/\*([^*]|\*+[^*/])*\*+/"
  ]
}

// Root rule
picatFile ::= module_declaration? item_*

private item_ ::= function_clause | predicate_clause | COMMENT | MULTI_LINE_COMMENT | general_directive

// Module declaration
module_declaration ::= MODULE_KEYWORD module_name DOT {pin=1}
module_name ::= atom

// Directives
general_directive ::= import_statement | export_statement | include_statement | using_statement | compilation_directive

compilation_directive ::= [PRIVATE_KEYWORD] (table_mode | index_mode) DOT {pin=1}
table_mode ::= TABLE_KEYWORD head_reference_list
index_mode ::= INDEX_KEYWORD head_reference_list [indexing_details]
head_reference_list ::= head_reference ( (COMMA | SEMICOLON) head_reference )*
head_reference ::= atom ["/" INTEGER]
indexing_details ::= LPAR argument_list RPAR

import_statement ::= IMPORT_KEYWORD import_list DOT {pin=1}
export_statement ::= EXPORT_KEYWORD export_list DOT {pin=1}
include_statement ::= INCLUDE_KEYWORD file_spec DOT {pin=1}
using_statement ::= USING_KEYWORD module_name [ "=>" rename_list ] DOT {pin=1}

import_list ::= import_item ( COMMA import_item )*
import_item ::= module_name [ "=>" rename_list ]
rename_list ::= rename_spec ( COMMA rename_spec )*
rename_spec ::= atom [ "=>" atom ]

export_list ::= export_spec ( COMMA export_spec )*
export_spec ::= predicate_signature | atom

file_spec ::= STRING | atom

// Predicate Clauses
predicate_clause ::= predicate_rule | predicate_fact

predicate_rule ::= head rule_operator body DOT {pin=2; recoverWhile=predicate_recover}
private predicate_recover ::= !DOT
predicate_fact ::= head DOT

// Function Clauses
function_clause ::= function_rule | function_fact

function_rule ::= head EQUAL function_body DOT {pin=2}
function_fact ::= head EQUAL expression DOT {pin=2}
function_body ::= expression [ rule_operator body ]

rule_operator ::= ARROW_OP | BACKTRACKABLE_ARROW_OP | BICONDITIONAL_OP | BACKTRACKABLE_BICONDITIONAL_OP | RULE_OP

// Heads
head ::= ( structure | atom_no_args | qualified_atom ) [ COMMA head_args ]
head_args ::= expression ( COMMA expression )*
qualified_atom ::= atom DOT atom
atom_no_args ::= atom
predicate_signature ::= atom "/" INTEGER

// Body
body ::= goal ( goal_separator goal )* {recoverWhile=body_recover}
goal_separator ::= SEMICOLON | COMMA
private body_recover ::= !(DOT | SEMICOLON | END_KEYWORD | EOF)

// Goals
goal ::= if_then_else
       | case_expression
       | try_catch
       | assignment
       | type_annotation
       | unification
       | comparison
       | negation
       | fail_goal
       | pass_goal
       | true_goal
       | false_goal
       | foreach_loop
       | while_loop
       | loop_while_statement
       | list_comprehension_goal
       | cut_goal
       | return_stmt
       | continue_stmt
       | break_stmt
       | throw_stmt
       | procedure_call
       | expression

// Goal implementations
if_then_else ::= IF_KEYWORD expression THEN_KEYWORD body [elseif_clauses] [ELSE_KEYWORD body] END_KEYWORD {pin=1}
elseif_clauses ::= elseif_clause+
elseif_clause ::= ELSEIF_KEYWORD expression THEN_KEYWORD body

assignment ::= assignable_expression ASSIGN_OP expression
assignable_expression ::= variable | atom_expression

type_annotation ::= variable DOUBLE_COLON_OP expression

unification ::= expression ( EQUAL | NOT_EQUAL | HASH_NOT_EQUAL_OP ) expression
comparison ::= expression ( LESS | GREATER | LESS_EQUAL | GREATER_EQUAL | HASH_LESS_EQUAL_OP | IDENTICAL | NOT_IDENTICAL | HASH_EQUAL_OP ) expression

negation ::= NOT_KEYWORD goal
fail_goal ::= FAIL_KEYWORD
pass_goal ::= PASS_KEYWORD
true_goal ::= TRUE_KEYWORD
false_goal ::= FALSE_KEYWORD

foreach_loop ::= FOREACH_KEYWORD LPAR foreach_generators RPAR body END_KEYWORD {pin=1}
foreach_generators ::= foreach_generator ( COMMA foreach_generator )*
foreach_generator ::= variable IN_KEYWORD expression | variable EQUAL expression

list_comprehension_goal ::= LBRACKET expression PIPE foreach_generators RBRACKET

procedure_call ::= atom_expression

cut_goal ::= CUT
return_stmt ::= RETURN_KEYWORD [expression]
continue_stmt ::= CONTINUE_KEYWORD
break_stmt ::= BREAK_KEYWORD
throw_stmt ::= THROW_KEYWORD expression

case_expression ::= CASE_KEYWORD expression OF_KEYWORD case_arms END_KEYWORD {pin=1}
case_arms ::= case_arm ( SEMICOLON case_arm )*
case_arm ::= pattern ARROW_OP body

try_catch ::= TRY_KEYWORD body catch_clauses [FINALLY_KEYWORD body] END_KEYWORD {pin=1}
catch_clauses ::= catch_clause+
catch_clause ::= CATCH_KEYWORD pattern ARROW_OP body

while_loop ::= WHILE_KEYWORD LPAR expression RPAR body END_KEYWORD {pin=1}
loop_while_statement ::= LOOP_KEYWORD body WHILE_KEYWORD LPAR expression RPAR DOT {pin=1}

// Patterns
pattern ::= variable | atom | number | structure_pattern | list_pattern | tuple_pattern | as_pattern
structure_pattern ::= atom LPAR [pattern_list] RPAR
list_pattern ::= LBRACKET [pattern_list] [PIPE pattern] RBRACKET
tuple_pattern ::= LBRACE [pattern_list] RBRACE
as_pattern ::= variable AT pattern
pattern_list ::= pattern ( COMMA pattern )*

// Basic elements
atom ::= IDENTIFIER | QUOTED_ATOM
number ::= INTEGER | FLOAT | HEX_INTEGER | OCTAL_INTEGER | BINARY_INTEGER
structure ::= atom LPAR [argument_list] RPAR
tuple ::= LBRACE [tuple_items] RBRACE
tuple_items ::= expression ( COMMA expression )*
argument_list ::= expression ( COMMA expression )*

// Expressions with proper precedence (left-recursion removed)
expression ::= conditional_expression

conditional_expression ::= biconditional_expression [ QUESTION_MARK expression COLON expression ]

biconditional_expression ::= logical_or_expression biconditional_expression_rest*
biconditional_expression_rest ::= ( BICONDITIONAL_OP | HASH_BICONDITIONAL_OP | BACKTRACKABLE_BICONDITIONAL_OP ) logical_or_expression

logical_or_expression ::= logical_and_expression logical_or_expression_rest*
logical_or_expression_rest ::= ( OR_KEYWORD | HASH_OR_OP ) logical_and_expression

logical_and_expression ::= bitwise_or_expression logical_and_expression_rest*
logical_and_expression_rest ::= ( AND_KEYWORD | HASH_AND_OP ) bitwise_or_expression

bitwise_or_expression ::= bitwise_xor_expression bitwise_or_expression_rest*
bitwise_or_expression_rest ::= PIPE bitwise_xor_expression

bitwise_xor_expression ::= bitwise_and_expression bitwise_xor_expression_rest*
bitwise_xor_expression_rest ::= ( CARET | XOR_KEYWORD | HASH_CARET_OP ) bitwise_and_expression

bitwise_and_expression ::= equality_expression bitwise_and_expression_rest*
bitwise_and_expression_rest ::= AMPERSAND equality_expression

equality_expression ::= relational_expression equality_expression_rest*
equality_expression_rest ::= ( IDENTICAL | NOT_IDENTICAL | HASH_EQUAL_OP | HASH_NOT_EQUAL_OP | EQUAL | NOT_EQUAL ) relational_expression

relational_expression ::= concatenation_expression relational_expression_rest*
relational_expression_rest ::= ( LESS | GREATER | LESS_EQUAL | GREATER_EQUAL | HASH_LESS_EQUAL_OP | IS_KEYWORD ) concatenation_expression

concatenation_expression ::= shift_expression concatenation_expression_rest*
concatenation_expression_rest ::= CONCAT_OP shift_expression

shift_expression ::= additive_expression shift_expression_rest*
shift_expression_rest ::= ( SHIFT_LEFT | SHIFT_RIGHT | SHIFT_RIGHT_TRIPLE_OP ) additive_expression

additive_expression ::= multiplicative_expression additive_expression_rest*
additive_expression_rest ::= ( PLUS | MINUS ) multiplicative_expression

multiplicative_expression ::= power_expression multiplicative_expression_rest*
multiplicative_expression_rest ::= ( MULTIPLY | DIVIDE | INT_DIVIDE | MOD_KEYWORD | DIV_KEYWORD | REM_KEYWORD ) power_expression

power_expression ::= unary_expression [ POWER power_expression ]

unary_expression ::= unary_operator* atom_expression

unary_operator ::= PLUS | MINUS | NOT_KEYWORD | BACKSLASH | HASH_TILDE_OP

atom_expression ::= base_expression postfix_expression*

postfix_expression ::= function_call_suffix | index_access_suffix | field_access_suffix

function_call_suffix ::= LPAR [argument_list] RPAR
index_access_suffix ::= LBRACKET expression [ COMMA expression ] RBRACKET
field_access_suffix ::= FIELD_ACCESS

base_expression ::= term_constructor_expression
                  | as_pattern_expression
                  | simple_number_range
                  | list_comprehension_expression
                  | list_expression
                  | tuple
                  | map
                  | lambda_expression
                  | dollar_term_constructor
                  | parenthesized_expression
                  | STRING
                  | atom
                  | number
                  | variable

parenthesized_expression ::= LPAR expression RPAR
dollar_term_constructor ::= DOLLAR goal
as_pattern_expression ::= variable AT pattern
lambda_expression ::= LBRACE [variable_list] RBRACE ARROW_OP (expression | body)
variable_list ::= variable ( COMMA variable )*
term_constructor_expression ::= (atom | qualified_atom) LBRACE map_entries RBRACE

simple_number_range ::= range_operand RANGE_OP range_operand
range_operand ::= INTEGER | variable | atom | parenthesized_expression

// Lists and Arrays
list_expression ::= LBRACKET [list_items] RBRACKET
list_items ::= expression ( ( COMMA | SEMICOLON ) expression )* [ PIPE expression ]
list_comprehension_expression ::= LBRACKET expression ( COLON | PIPE ) foreach_generators RBRACKET

// Maps
map ::= LBRACE [map_entries] RBRACE
map_entries ::= map_entry ( COMMA map_entry )*
map_entry ::= expression COLON expression
