{
  parserClass="com.github.avrilfanomar.picatplugin.language.parser.PicatParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Picat"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.avrilfanomar.picatplugin.language.psi"
  psiImplPackage="com.github.avrilfanomar.picatplugin.language.psi.impl"

  elementTypeHolderClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenTypes"
  elementTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatElementType"
  tokenTypeClass="com.github.avrilfanomar.picatplugin.language.psi.PicatTokenType"

  tokens = [
    // Keywords
    MODULE_KEYWORD="module"
    END_MODULE_KEYWORD="end_module"
    IMPORT_KEYWORD="import"
    EXPORT_KEYWORD="export"
    INCLUDE_KEYWORD="include"
    IF_KEYWORD="if"
    THEN_KEYWORD="then"
    ELSEIF_KEYWORD="elseif"
    ELSE_KEYWORD="else"
    END_KEYWORD="end"
    FOREACH_KEYWORD="foreach"
    IN_KEYWORD="in"
    LOOP_KEYWORD="loop"
    PRIVATE_KEYWORD="private"
    TABLE_KEYWORD="table"
    INDEX_KEYWORD="index"
    RETURN_KEYWORD="return"
    CONTINUE_KEYWORD="continue"
    BREAK_KEYWORD="break"
    NOT_KEYWORD="not"
    FAIL_KEYWORD="fail"
    TRUE_KEYWORD="true"
    FALSE_KEYWORD="false"
    CASE_KEYWORD="case"
    OF_KEYWORD="of"
    TRY_KEYWORD="try"
    CATCH_KEYWORD="catch"
    FINALLY_KEYWORD="finally"
    THROW_KEYWORD="throw"
    USING_KEYWORD="using"
    WHILE_KEYWORD="while"
    DO_KEYWORD="do"
    PASS_KEYWORD="pass"

    // Operators
    ARROW_OP="=>"
    BACKTRACKABLE_ARROW_OP="?=>"
    BICONDITIONAL_OP="<=>"
    BACKTRACKABLE_BICONDITIONAL_OP="?<=>"
    HASH_BICONDITIONAL_OP="#<=>"
    HASH_ARROW_OP="#=>"
    HASH_OR_OP="#\\/"
    HASH_CARET_OP="#^"
    HASH_AND_OP="#/\\"
    HASH_TILDE_OP="#~"
    RULE_OP=":-"
    ASSIGN_OP=":="
    RANGE_OP=".."
    EQUAL="="
    NOT_EQUAL="!="
    LESS="<"
    GREATER=">"
    LESS_EQUAL="<="
    GREATER_EQUAL=">="
    IDENTICAL="=:="
    NOT_IDENTICAL="=\\="
    PLUS="+"
    MINUS="-"
    MULTIPLY="*"
    POWER="**"
    DIVIDE="/"
    INT_DIVIDE="//"
    DIV_KEYWORD="div"
    REM_KEYWORD="rem"
    MOD_KEYWORD="mod"
    SHIFT_LEFT="<<"
    SHIFT_RIGHT=">>"
    SHIFT_RIGHT_TRIPLE_OP=">>>"
    BACKSLASH="\\"
    AND_KEYWORD="and"
    OR_KEYWORD="or"
    XOR_KEYWORD="xor"
    CARET="^"
    AMPERSAND="&"
    PIPE="|"
    IS_KEYWORD="is"
    DOT_OP="."
    CONCAT_OP="++"

    // Separators
    DOT="." // Note: DOT_OP is for the operator, DOT is for structure access/end of statement.
    EOR="regexp:\.\s+" // End of Rule/Statement: . followed by whitespace
    COMMA=","
    SEMICOLON=";"
    COLON=":"
    LPAR="("
    RPAR=")"
    LBRACKET="["
    RBRACKET="]"
    LBRACE="{"
    RBRACE="}"
    CUT="!"
    PIPE_CHOICE="|"
    AT="@"

    // Literals (expanded)
    IDENTIFIER="regexp:[a-z][a-zA-Z0-9_]*"
    VARIABLE="regexp:[A-Z][a-zA-Z0-9_]*"
    ANONYMOUS_VARIABLE="regexp:_[a-zA-Z0-9_]*"
    INTEGER="regexp:[0-9]+"
    HEX_INTEGER="regexp:0[xX][0-9a-fA-F]+"
    OCTAL_INTEGER="regexp:0[oO][0-7]+"
    BINARY_INTEGER="regexp:0[bB][01]+"
    FLOAT="regexp:[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?"
    STRING="regexp:\"([^\"\\]|\\.)*\""
    QUOTED_ATOM="regexp:'([^'\\]|\\.)*'"
    COMMENT="regexp:%[^\r\n]*"
    MULTI_LINE_COMMENT="regexp:/\*([^*]|\*+[^*/])*\*+/"
  ]
}

// Root rule
picatFile ::= program

program ::= item_*

// private item_ ::= (module_decl | directive | fact | function_definition | rule | statement | COMMENT | MULTI_LINE_COMMENT)
// Updated item_ to reflect new granular definitions and actor support
private item_ ::= (module_decl | general_directive | predicate_clause | function_clause | actor_definition | statement | COMMENT | MULTI_LINE_COMMENT)


// Module declaration
module_decl ::= module_declaration end_module_declaration?
module_declaration ::= MODULE_KEYWORD module_name [export_clause] [import_clause] EOR { pin=1 }
end_module_declaration ::= END_MODULE_KEYWORD [module_name] EOR { pin=1 }
module_name ::= atom

export_clause ::= EXPORT_KEYWORD export_list { pin=1 } // Assuming export list itself doesn't need EOR termination per item
import_clause ::= IMPORT_KEYWORD import_list { pin=1 } // Assuming import list itself doesn't need EOR termination per item

// Directives
// Renamed 'directive' to 'general_directive' and added compilation_directive
general_directive ::= import_statement | export_statement | include_statement | using_statement | compilation_directive {
  elementType = DIRECTIVE // Keep a general type for all directives if useful
}

compilation_directive ::= [PRIVATE_KEYWORD] (table_mode | index_mode) EOR {pin=1}
table_mode ::= TABLE_KEYWORD head_reference_list
index_mode ::= INDEX_KEYWORD head_reference_list [indexing_details]
head_reference_list ::= head_reference ((COMMA | SEMICOLON) head_reference)*
head_reference ::= atom ('/' INTEGER)? // e.g., pred/2 or func/1
indexing_details ::= LPAR argument_list RPAR // e.g., (Arg1, _ , Arg3)


import_statement ::= IMPORT_KEYWORD import_list EOR { pin=1 }
export_statement ::= EXPORT_KEYWORD export_list EOR { pin=1 }
include_statement ::= INCLUDE_KEYWORD file_spec EOR { pin=1 }
using_statement ::= USING_KEYWORD module_name ["=>" rename_list] EOR { pin=1 }

import_list ::= import_item ("," import_item)*
import_item ::= module_name ["=>" rename_list] // Was module_spec
rename_list ::= rename_spec ("," rename_spec)*
rename_spec ::= atom ["=>" atom]

export_list ::= export_spec ("," export_spec)*
export_spec ::= rule | atom

file_spec ::= STRING | atom

// Predicate Clauses (formerly fact and rule)
// predicate_definition is a sequence of predicate_clauses and compilation_directives
// predicate_rule_or_fact in prompt, here represented by predicate_clause
predicate_clause ::= predicate_rule | predicate_fact

private predicate_rule ::= head RULE_OP body EOR { // Renamed from 'rule'
  pin=1 // head is usually the pinned element
  elementType = PREDICATE_RULE // New element type
  // Add implements/extends if a new PSI class is created
}

private predicate_fact ::= head EOR { // Renamed from 'fact'
  pin=1
  elementType = PREDICATE_FACT // New element type
  // Add implements/extends if a new PSI class is created
}


// Function Clauses (formerly function_definition, plus new function_fact)
// function_definition is a sequence of function_clauses and compilation_directives
// function_rule_or_fact in prompt, here represented by function_clause
function_clause ::= function_rule | function_fact

private function_rule ::= head ASSIGN_OP function_body EOR { // Renamed from 'function_definition'
  pin=1 // head is pinned
  elementType = FUNCTION_RULE // New element type
  // Add implements/extends if a new PSI class is created for function_rule
}

private function_fact ::= head ASSIGN_OP expression EOR { // New rule for function facts
  pin=1
  elementType = FUNCTION_FACT // New element type
  // Add implements/extends if a new PSI class is created
}

function_body ::= expression { // This rule remains the same
  elementType = FUNCTION_BODY
  implements="com.github.avrilfanomar.picatplugin.language.psi.PicatFunctionBody"
  methods=[getReturnExpression getStatements]
  extends="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatFunctionBodyImpl"
}

// Actor Definition
// actor_definition as per prompt
actor_definition ::= [PRIVATE_KEYWORD] actor_name EOR (actor_member EOR)* END_KEYWORD EOR {
    elementType = ACTOR_DEFINITION
}
actor_name ::= atom // Or head if actors can have arguments in their declaration
actor_member ::= action_rule | predicate_clause | function_clause | compilation_directive
// action_rule as per prompt
action_rule ::= head HASH_ARROW_OP body { // Using HASH_ARROW_OP (#=>) for actions
    elementType = ACTION_RULE
}
// Note: HASH_ARROW_OP was added in the previous step's token updates.


rule_operator ::= "=>" | "?=>" | "<=>" | "?<=>" | ":-" // Standard rule operators

// Heads
head ::= atom_no_args | structure | qualified_atom
qualified_atom ::= atom "." atom
atom_no_args ::= atom !LPAR

// Body
// body rule structure seems fine for disjunctive/conjunctive goals.
// No changes needed to 'body' structure itself based on disjunctive_goal/conjunctive_goal terms in prompt.
body ::= goal ((";" | ",") goal)* [cut] { recoverWhile=body_recover }
private body_recover ::= !(EOR | END_KEYWORD)

// Goals
// Added loop_while_statement to the list of possible goals.
// negative_goal is covered by 'negation'.
goal ::= call
       | if_then_else
       | case_expression
       | try_catch
       | assignment
       | unification
       | comparison
       | arithmetic_comparison
       | negation
       | fail
       | pass
       | true_goal
       | false_goal
       | not_goal
       | foreach_loop
       | while_loop
       | loop_while_statement // Added new loop type
       | list_comprehension
       | procedure_call
       | cut
       | return_stmt
       | continue_stmt
       | break_stmt
       | throw_stmt

// Goal implementations
call ::= atom | structure // condition rule is typically 'expression', no separate 'condition' rule needed.
if_then_else ::= IF_KEYWORD expression THEN_KEYWORD body [elseif_clause] [ELSE_KEYWORD body] END_KEYWORD
elseif_clause ::= ELSEIF_KEYWORD expression THEN_KEYWORD body [elseif_clause]
assignment ::= variable ":=" expression
unification ::= expression "=" expression | expression "!=" expression
comparison ::= expression comparison_operator expression
comparison_operator ::= "<" | ">" | "<=" | ">="
arithmetic_comparison ::= expression arithmetic_comparison_operator expression
arithmetic_comparison_operator ::= "=:=" | "=\\="
// negation rule updated to include HASH_TILDE_OP as an alternative to NOT_KEYWORD for goal negation, if appropriate.
// However, HASH_TILDE_OP is added to unary_expression as per plan. 'negation' rule here is for NOT_KEYWORD goal.
// If #~ p is a valid goal where p is a goal, then 'negation ::= (NOT_KEYWORD | HASH_TILDE_OP) goal' would be right.
// For now, assuming #~ is purely for expressions as per token type and common usage.
negation ::= NOT_KEYWORD goal
fail ::= FAIL_KEYWORD
pass ::= PASS_KEYWORD
true_goal ::= TRUE_KEYWORD
false_goal ::= FALSE_KEYWORD
not_goal ::= negation // This is an alias, effectively.
foreach_loop ::= FOREACH_KEYWORD "(" foreach_generators ")" body END_KEYWORD {
  elementType = FOREACH_LOOP
  implements="com.github.avrilfanomar.picatplugin.language.psi.PicatForeachLoop"
  extends="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatForeachLoopImpl"
}
foreach_generators ::= foreach_generator ("," foreach_generator)*
foreach_generator ::= variable "in" expression | variable "=" expression
list_comprehension ::= "[" expression "|" foreach_generators "]"
procedure_call ::= atom "(" [argument_list] ")"
cut ::= "!"
return_stmt ::= RETURN_KEYWORD expression
continue_stmt ::= CONTINUE_KEYWORD
break_stmt ::= BREAK_KEYWORD
throw_stmt ::= THROW_KEYWORD expression

// New control structures
case_expression ::= CASE_KEYWORD expression OF_KEYWORD case_arms END_KEYWORD
case_arms ::= case_arm (";" case_arm)*
case_arm ::= pattern "=>" body

try_catch ::= TRY_KEYWORD body CATCH_KEYWORD catch_clauses [FINALLY_KEYWORD body] END_KEYWORD
catch_clauses ::= catch_clause (";" catch_clause)*
// 'pattern' in catch_clause serves as 'exception_pattern'
catch_clause ::= pattern "=>" body

while_loop ::= WHILE_KEYWORD expression DO_KEYWORD body END_KEYWORD {
  elementType = WHILE_LOOP
  implements="com.github.avrilfanomar.picatplugin.language.psi.PicatWhileLoop"
  extends="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatWhileLoopImpl"
}

// New loop_while construct
loop_while_statement ::= LOOP_KEYWORD body WHILE_KEYWORD expression EOR {pin=1 elementType=LOOP_WHILE_STATEMENT}


// Patterns
// pattern rule seems general enough for exception_pattern as well.
pattern ::= variable | atom | number | "_" | structure_pattern | list_pattern | tuple_pattern
structure_pattern ::= atom "(" [pattern_list] ")"
list_pattern ::= "[" [pattern_list] ["|" pattern] "]"
tuple_pattern ::= "{" [pattern_list] "}"
pattern_list ::= pattern ("," pattern)*

// Basic elements
atom ::= IDENTIFIER | QUOTED_ATOM
variable ::= VARIABLE | ANONYMOUS_VARIABLE
number ::= INTEGER | FLOAT | HEX_INTEGER | OCTAL_INTEGER | BINARY_INTEGER
structure ::= "$"? atom "(" [argument_list] ")" {
  elementType = STRUCTURE
  implements="com.github.avrilfanomar.picatplugin.language.psi.PicatStructure"
  methods=[getIdentifier getArgumentList getName getArity]
  extends="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatStructureImpl"
}
tuple ::= "{" [tuple_items] "}"
tuple_items ::= expression ("," expression)*
argument_list ::= expression ("," expression)*

// Expressions
// Expressions
// Modified expression hierarchy to integrate new logical operators and implication/biconditional levels.
expression ::= biconditional_expression_level { // Root of expression hierarchy changed
  elementType = EXPRESSION
  implements="com.github.avrilfanomar.picatplugin.language.psi.PicatExpression"
  methods=[getTerms getOperators]
  extends="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatExpressionImpl"
}

biconditional_expression_level ::= implication_expression_level ((BICONDITIONAL_OP | HASH_BICONDITIONAL_OP | BACKTRACKABLE_BICONDITIONAL_OP) implication_expression_level)*
implication_expression_level ::= conditional_expression ((ARROW_OP | HASH_ARROW_OP | BACKTRACKABLE_ARROW_OP) conditional_expression)*
// conditional_expression is the ternary operator ? :
conditional_expression ::= logical_or_expression ("?" expression ":" expression)? // Changed structure slightly for ternary

// Logical operators with new hash alternatives
logical_or_expression ::= logical_and_expression ((OR_KEYWORD | HASH_OR_OP) logical_and_expression)*
logical_and_expression ::= bitwise_or_expression ((AND_KEYWORD | HASH_AND_OP) bitwise_or_expression)*

// Bitwise operators with new hash alternatives (XOR_KEYWORD also added here)
bitwise_or_expression ::= bitwise_xor_expression (PIPE bitwise_xor_expression)* // Standard bitwise OR is just PIPE
bitwise_xor_expression ::= bitwise_and_expression ((CARET | XOR_KEYWORD | HASH_CARET_OP) bitwise_and_expression)*
bitwise_and_expression ::= equality_expression (AMPERSAND equality_expression)* // Standard bitwise AND is just AMPERSAND

// Equality, Relational, Shift, Additive, Multiplicative, Power remain structurally similar
equality_expression ::= relational_expression (("=:=" | "=\\=") relational_expression)*
relational_expression ::= shift_expression (("<" | ">" | "<=" | ">=") shift_expression)*
// Shift expression with new SHIFT_RIGHT_TRIPLE_OP (>>>)
shift_expression ::= additive_expression ((SHIFT_LEFT | SHIFT_RIGHT | SHIFT_RIGHT_TRIPLE_OP) additive_expression)*
additive_expression ::= multiplicative_expression ((PLUS | MINUS) multiplicative_expression)* // Corrected: was ("+" | "-")
// Multiplicative expression with new DIV_KEYWORD (div) and REM_KEYWORD (rem)
multiplicative_expression ::= power_expression ((MULTIPLY | DIVIDE | INT_DIVIDE | MOD_KEYWORD | DIV_KEYWORD | REM_KEYWORD) power_expression)*
power_expression ::= unary_expression ("**" unary_expression)*

// Unary expression with new HASH_TILDE_OP
unary_expression ::= (PLUS | MINUS | NOT_KEYWORD | BACKSLASH | HASH_TILDE_OP) primary_expression

// Primary Expressions Updated
primary_expression ::=
    atom
  | number
  | variable
  | list_expression // Changed from 'list' to 'list_expression' for clarity
  | tuple // Represents array_expression with {}
  | map // Explicit map expression
  | index_access_expression
  | as_pattern_expression
  | lambda_expression
  | term_constructor_expression
  | list_comprehension_expression // List comprehensions as expressions
  | dollar_term_constructor    // Added $goal$ term constructor
  | LPAR expression RPAR         // Parenthesized expression
  | function_call

// Dollar Term Constructor: $ goal $
dollar_term_constructor ::= "$" goal "$" {elementType=DOLLAR_TERM_CONSTRUCTOR}

// Definition of a 'term' as per grammar description (basic data items)
// This rule is for semantic understanding or specific contexts where only terms are allowed.
// It's not directly part of the main expression parsing hierarchy in this form,
// as expression rules already correctly parse these elements.
// If 'term' is needed for specific rules (e.g. 'variable "@" term'), 'pattern' might be more appropriate there.
// For now, 'term' is defined for clarity but not replacing existing expression elements.
// term ::= atom | number | variable | list_expression | tuple | structure | STRING // STRING was missing in old primary_expression options

// Index Access: variable "[" argument ["," argument] "]"
index_access_expression ::= variable LBRACKET expression (COMMA expression)? RBRACKET {elementType=INDEX_ACCESS_EXPRESSION}

// As-Pattern: variable "@" term ["@"] (using pattern for term)
as_pattern_expression ::= variable AT pattern AT? {elementType=AS_PATTERN_EXPRESSION}

// Lambda Terms / Expressions
lambda_expression ::= LBRACE variable_list? RBRACE ARROW_OP (expression | body) {elementType=LAMBDA_EXPRESSION}
variable_list ::= variable (COMMA variable)*

// Term Constructor: e.g., point{x:1, y:2}
term_constructor_expression ::= (atom | qualified_atom) LBRACE map_entries RBRACE {elementType=TERM_CONSTRUCTOR_EXPRESSION}


// Function Calls (no changes from previous version, seems robust)
function_call ::= atom LPAR argument_list? RPAR | builtin_call
builtin_call ::= builtin_name LPAR argument_list? RPAR
builtin_name ::= "call" | "apply" | "new_struct" | "new_map"


// List and Array Expressions
// list_expression is the updated name for 'list'
list_expression ::= LBRACKET list_items? RBRACKET { // made list_items optional for "[]"
  elementType = LIST // Keeping original elementType if it aligns
  implements="com.github.avrilfanomar.picatplugin.language.psi.PicatList"
  extends="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatListImpl"
}
  elementType = LIST
  implements="com.github.avrilfanomar.picatplugin.language.psi.PicatList"
  methods=[getListElements]
  extends="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatListImpl"
}
list_items ::= expression ((COMMA | SEMICOLON) expression)* (PIPE expression)? { // Changed from ["|" expression]
  elementType = LIST_ELEMENTS
  implements="com.github.avrilfanomar.picatplugin.language.psi.PicatListElements"
  methods=[getExpressions getTailExpression]
  extends="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatListElementsImpl"
}
// List Comprehension as an expression
list_comprehension_expression ::= LBRACKET expression PIPE foreach_generators RBRACKET {elementType=LIST_COMPREHENSION_EXPRESSION}
// `foreach_generators` is already defined under goal `foreach_loop`.

// `tuple` (curly braces) can serve as Picat's "array_expression"
// `map` is for key-value stores.

// Operators (General operator rule, not directly used in expression hierarchy but useful for other parser aspects)
// This 'operator' rule is likely for defining operators in directives, not for parsing expressions themselves.
// The expression hierarchy itself defines operator parsing.
operator ::= PLUS | MINUS | MULTIPLY | DIVIDE | MOD_KEYWORD | POWER | SHIFT_LEFT | SHIFT_RIGHT | SHIFT_RIGHT_TRIPLE_OP |
             BACKSLASH | INT_DIVIDE | DIV_KEYWORD | REM_KEYWORD |
             AND_KEYWORD | OR_KEYWORD | XOR_KEYWORD | CARET | AMPERSAND | PIPE | IS_KEYWORD |
             HASH_AND_OP | HASH_OR_OP | HASH_CARET_OP | HASH_TILDE_OP | HASH_ARROW_OP | HASH_BICONDITIONAL_OP {
  elementType = OPERATOR
  implements="com.github.avrilfanomar.picatplugin.language.psi.PicatOperator"
  methods=[getOperatorText getPrecedence]
  extends="com.github.avrilfanomar.picatplugin.language.psi.impl.PicatOperatorImpl"
}

// Maps
map ::= "{" [map_entries] "}"
map_entries ::= map_entry ("," map_entry)*
map_entry ::= expression ":" expression
